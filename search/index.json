[{"content":"Why the Anne 2 Pro i want to improve my writing speed and so i bought a 60/100 keybord, i ended up with the Anne2Pro because of build quality and bluethoot compatibility\nBasic version I choose the black version with Cherry MX Brown and overall looks pretty solid and beautyfull, anyway it\u0026rsquo;s for sure upgradable\nTeardown Let\u0026rsquo;s start by removing keycaps Remove the 5 T5 screw from the board then remove the board and the battery from the old case The battery is fixed on the bottom of the case but with just a little pressure comes out Case For the case i choose a full resin case from kdbfans LINK\nThen i made a foam mod with neoprene\nI also taped the rear of the board\nAnd reinstall the battery in his slot and the board\nKeycaps For the keycaps i choose the GMK hammerhead (DARK BASE COLOUR)\nI bought also some 0.1 mm oring for make the button pressing more quite and install a oring on every keycaps\nFinal result Tell me what you think on the final look of this modded Anne2Pro and how you would improve it ","date":"2022-06-29T20:03:36+02:00","image":"https://www.matteobianchi.eu/p/a2p-mods/images/1_hu0b7ff0303096b350197fdda063620d06_71716_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.matteobianchi.eu/p/a2p-mods/","title":"Anne 2 Pro Mods"},{"content":"\n12_R assignament Request What is the \u0026ldquo;Brownian motion\u0026rdquo; and what is a Wiener process. History, importance, definition and applications (Bachelier, Wiener, Einstein, \u0026hellip;):\nBrownian Motion Brownian motion refers to either the physical phenomenon that minute particles immersed in a fluid move around randomly or the mathematical models used to describe those random movements.[1]\nBrownian motion was discovered by the biologist Robert Brown in 1827.\nWhile Brown was studying pollen particles floating in water in the microscope, he observed minute particles in the pollen grains executing the jittery motion.\nAfter repeating the experiment with particles of dust, he was able to conclude that the motion was due to pollen being “alive” but the origin of the motion remained unexplained.\nThe first one to give a theory of Brownian motion was Louis Bachelier in 1900 in his PhD thesis “The theory of speculation”. However, it was only in 1905 that Albert Einstein, using a probabilistic model, could sufficiently explain Brownian motion. He observed that if the kinetic energy of fluids was right, the molecules of water moved at random.\nThus, a small particle would receive a random number of impacts of random strength and from random directions in any short period of time. This random bombardment by the molecules of the fluid would cause a sufficiently small particle to move exactly just how Brown described it.\nWiener process In mathematics, Brownian motion is described by the Wiener process, a continuous-time stochastic process named in honor of Norbert Wiener. It is one of the best known Lévy processes (càdlàg stochastic processes with stationary independent increments) and occurs frequently in pure and applied mathematics, economics and physics.\nThe Wiener process Wt is characterized by four facts:\nW0 = 0 Wt is almost surely continuous Wt has independent increments Wt-Ws ~ N(0,t-s)(for 0\u0026lt;= s\u0026lt;=t) Brownian motion is a well-suited model for a wide range of real random phenomena, from chaotic oscillations of microscopic objects, such as flower pollen in water, to stock market fluctuations. It is also a purely abstract mathematical tool which can be used to prove theorems in “deterministic” fields of mathematics. [1]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://en.wikipedia.org/wiki/Brownian_motion\"\n","date":"2021-11-21T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/12r/","title":"12R"},{"content":"\n10_R assignament Request Distributions of the order statistics: look on the web for the most simple (but still rigorous) and clear derivations of the distributions, explaining in your own words the methods used.\nOrder statistics Together with rank statistics, order statistics are among the most fundamental tools in non-parametric statistics and inference. In statistics we define the kth order statistic of a statistical sample as its kth-smallest value.[1]\nImportant special cases of the order statistics are the minimum and maximum value of a sample, and the sample median and other sample quantiles.\nWhen using probability theory to analyze order statistics of random samples from a continuous distribution, the cumulative distribution function is used to reduce the analysis to the case of order statistics of the uniform distribution.\nProbability density functions of the order statistics for a sample of size n = 5 from an exponential distribution with unit scale parameter\nDistributions function of order statistic For a random sample as above, with cumulative distribution Fx(x), the order statistics for that sample have cumulative distributions as follows (where r specifies which order statistic):\nthe corresponding probability density function may be derived from this result, and is found to be:\nMoreover, there are two special cases, which have CDFs which are easy to compute. Which can be derived by careful consideration of probabilities.\n[1]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://en.wikipedia.org/wiki/Order_statistic\"\n","date":"2021-11-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/10_r/","title":"10_R"},{"content":"\n11_R assignament Request Do a research about the general correlation coefficient for ranks and the most common indices that can be derived by it. Do one example of computation of these correlation coefficients for ranks.\nGeneral correlation coefficient for ranks In statistics, a rank correlation is any of several statistics that measure an ordinal association—the relationship between rankings of different ordinal variables or different rankings of the same variable, where a “ranking” is the assignment of the ordering labels “first”, “second”, “third”, etc. to different observations of a particular variable.\nA rank correlation coefficient measures the degree of similarity between two rankings, and can be used to assess the significance of the relation between them.\nSome of the more popular rank correlation statistics include\nSpearman’s ρ Kendall’s τ Goodman and Kruskal’s γ Somers’ D An increasing rank correlation coefficient implies increasing agreement between rankings. The coefficient is inside the interval [−1, 1] and assumes the value:\n1 if the agreement between the two rankings is perfect; the two rankings are the same. 0 if the rankings are completely independent. −1 if the disagreement between the two rankings is perfect; one ranking is the reverse of the other. Following Diaconis (1988), a ranking can be seen as a permutation of a set of objects. Thus we can look at observed rankings as data obtained when the sample space is (identified with) a symmetric group. We can then introduce a metric, making the symmetric group into a metric space. Different metrics will correspond to different rank correlations.\nTo illustrate the computation, suppose a coach trains long-distance runners for one month using two methods. Group A has 5 runners, and Group B has 4 runners. The stated hypothesis is that method A produces faster runners. The race to assess the results finds that the runners from Group A do indeed run faster, with the following ranks: 1, 2, 3, 4, and 6. The slower runners from Group B thus have ranks of 5, 7, 8, and 9.\nThe analysis is conducted on pairs, defined as a member of one group compared to a member of the other group. For example, the fastest runner in the study is a member of four pairs: (1,5), (1,7), (1,8), and (1,9). All four of these pairs support the hypothesis, because in each pair the runner from Group A is faster than the runner from Group B. There are a total of 20 pairs, and 19 pairs support the hypothesis. The only pair that does not support the hypothesis are the two runners with ranks 5 and 6, because in this pair, the runner from Group B had the faster time. By the Kerby simple difference formula, 95% of the data support the hypothesis (19 of 20 pairs), and 5% do not support (1 of 20 pairs), so the rank correlation is r = .95 – .05 = .90.\nThe maximum value for the correlation is r = 1, which means that 100% of the pairs favor the hypothesis. A correlation of r = 0 indicates that half the pairs favor the hypothesis and half do not; in other words, the sample groups do not differ in ranks, so there is no evidence that they come from two different populations. An effect size of r = 0 can be said to describe no relationship between group membership and the members’ ranks.\n[1]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://en.wikipedia.org/wiki/Rank_correlation\"\n","date":"2021-11-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/11_r/","title":"11_R"},{"content":"\n13_R assignament Request An \u0026ldquo;analog\u0026rdquo; of the CLT for stochastic process: the standard Wiener process as \u0026ldquo;scaling limit\u0026rdquo; of a random walk and the functional CLT (Donsker theorem) or invariance principle. Explain the intuitive meaning of this result and how you have already illustrated the result in your homework.\nDonsker’s theorem In probability theory, Donsker’s theorem (also known as Donsker’s invariance principle, or the functional central limit theorem), named after Monroe D. Donsker, is a functional extension of the central limit theorem.[1 ]\nLet X1,X2,X3\u0026hellip; be a sequence of independent and identically distributed random variables with mean 0 and variance 1. and lets take S:= (Sn) where Sn is the sum of all Xi\nThe stochastic process S is known as a random walk. Define the diffusively rescaled random walk (partial-sum process) by:\nThe central limit theorem asserts that W^(n)(1) converges in distribution to a standard Gaussian random variable W(1) when n -\u0026gt; ∞.\nDonsker’s invariance principle extends this convergence to the whole function W^(n):=hj(W^(n)(t) with t in 0,1\nSo Donkers\u0026rsquo;s theorem states that as random varabile taken values in a Skorokhod space the random function W^(n) converges in distribution to a standard Brownian motion for n -\u0026gt; ∞.(Donsker\u0026rsquo;s invariance principle). This concept is used among the other field for assets price inference [1]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://en.wikipedia.org/wiki/Donsker%27s_theorem \u0026quot;\n","date":"2021-11-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/13_r/","title":"13_R"},{"content":"\n8_RA assignament Request Find out on the web what you have just generated in the previous application. Can you find out about all the well known distributions that \u0026ldquo;naturally arise\u0026rdquo; in this process ?\nThe Poisson distribution When in the 11A we calculate the single and double jump we find out ones of the most important distribution of statistic the Possion distribution, in fact the poisson distribution express the probability that a certain number of independent event happen.\nThe Poisson process A Poisson process is a simple and widely used stochastic process for modeling the times at which arrivals enter a system. For the Poisson process, arrivals may occur at arbitrary positive times, and the probability of an arrival at any particular instant is 0. This means that there is no very clean way of describing a Poisson process in terms of the probability of an arrival at any given instant. It is more convenient infact to define a Poisson process in terms of the sequence of interarrival times[2]\nArrival process Is a sequence of sums of interarrival times 0\u0026lt;S1\u0026lt;S2 each ones callaed arrival epochs and represent the times at wich some repeting event occurs.\nDefinition of the Poisson process The resulting random process is called a Poisson process with rate (or intensity) λ. Here is a formal definition of the Poisson process.\nLet λ\u0026gt;0 be fixed. The counting process {N(t),t∈[0,∞)} is called a Poisson process with rates λ if all the following conditions hold:\nN(0)=0; N(t) has independent increments; the number of arrivals in any interval of length τ\u0026gt;0 has Poisson(λτ) distribution. Poisson Distributions A discrete random variable X is said to have a Poisson distribution, with parameter λ\u0026gt;0 if it has a probability mass function given by:\nhere:\nk is the number of occurrences (k=0,1,2\u0026hellip;) e is Euler\u0026rsquo;s number ( e=2.71828\u0026hellip;) ! is the factorial function. [1]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://www.probabilitycourse.com/chapter11/11_1_2_basic_concepts_of_the_poisson_process.phpk\" [2]\u0026ldquo;url\u0026quot;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-262-discrete-stochastic-processes-spring-2011/course-notes/MIT6_262S11_chap02.pdf\u0026rdquo; [3]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://towardsdatascience.com/the-poisson-distribution-and-poisson-process-explained-4e2cb17d459\" [4]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://en.wikipedia.org/wiki/Poisson_distributiohttps://en.wikipedia.org/wiki/Poisson_distributionn\"\n","date":"2021-11-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/8_ra/","title":"8_RA"},{"content":"\n9_RA assignament Request Try to find on the web what are the names of the random variables that you just simulated in the applications, and see if the means and variances that you obtain in the simulation are compatible with the \u0026ldquo;theory\u0026rdquo;. If not fix the possible bugs.\nBrawnian motion In our application we can observe the behavior of the brownian motion properties.\nIs verified observing from the image that the starting point is x=0 y=0\nIs verified by observing that the graphic is continuous in every path.\nIs verified by the fact that increments are independent and random, in fact all the values generated have the the same probability of being chosen. No increment will therefore influence the next one.\nThe histograms represent the distribution of the brownian motion which is a realization of a normal distribution, we found infact that more sample we take the more the histograms take the beel form(the form of a normal distribution).\nNormal distributions realization In the last homework we take an important distributions the Normal(0,1) and make some trasformation:\nExp(N(0,1)) this is very intresting in fact we found it when we talk about Log-normal distribution[1]. Squared N(0,1) this is called chi-squared distribution with one degree of freedom {A chi-squared distribution constructed by squaring a single standard normal distribution is said to have 1 degree of freedom.Just as extreme values of the normal distribution have low probability (and give small p-values), extreme values of the chi-squared distribution have low probability.[2]} The generalazied sum of different(k) squared normal distribution make the grade of freedoom higher(k degree of freedoom); an important result is that since this distribution is the sum of k independent random variables with finite mean and variance, it converges to a normal distribution for large k.This is for sure insured by The CTL. For many practical purposes, for k\u0026gt;50 the distribution is sufficiently close to a normal distribution for the difference to be ignored.\n[1]\u0026ldquo;url\u0026rdquo;:\u0026ldquo;https://en.wikipedia.org/wiki/Log-normal_distribution\" [2]\u0026ldquo;url\u0026rdquo;:\u0026ldquo;https://en.wikipedia.org/wiki/Chi-squared_distribution#:~:text=A%20chi%2Dsquared%20distribution%20constructed,have%201%20degree%20of%20freedom.\u0026text=Just%20as%20extreme%20values%20of,squared%20distribution%20have%20low%20probability.\"\n","date":"2021-11-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/9_ra/","title":"9_RA"},{"content":"\n10_A assignament Request Given a random variable, extract m samples of size n and plot the empirical distribution of its mean (histogram), the first and the last order statistics. Comment on what you see.\nMy Solution Code in C#\nClass for graphicate the histogram\u0026rsquo;s 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 private void disegnaIstogrammi(Rectangle viewPort, Tuple\u0026lt;Dictionary\u0026lt;double, int\u0026gt;, Dictionary\u0026lt;decimal, int\u0026gt;, Dictionary\u0026lt;decimal, int\u0026gt;\u0026gt; tuple) { int i = 0; SolidBrush semiTransBrush = new SolidBrush(Color.FromArgb(128, 0, 0, 0)); foreach (var v in tuple.Item1) { int x, y; int width, height; // in this case on the fly trasformation is way faster x = (int)(this.viewPort.Left + 20 * i); y = (int)(viewPort.Top + viewPort.Height / 4 - v.Value / 10); width = 15; height = v.Value / 10; Rectangle rectangle = new Rectangle(x, y, width, height); g2.DrawRectangle(Pens.Black, rectangle); g2.FillRectangle(semiTransBrush, rectangle); g2.FillRectangle(Brushes.Cyan, rectangle); g2.DrawString(((decimal)v.Key).ToString(), new Font(\u0026#34;Calibri\u0026#34;, 10.0f, FontStyle.Regular, GraphicsUnit.Pixel), semiTransBrush, new Point(x, y+v.Value/10+1)); i++; } g2.DrawString(\u0026#34;Distribuzione originale \u0026#34;, new Font(\u0026#34;Calibri\u0026#34;, 13.0f, FontStyle.Italic, GraphicsUnit.Pixel), semiTransBrush, new Point(this.viewPort.Left - 140, (viewPort.Top + viewPort.Height/4))); i = 0; foreach (var v in tuple.Item2) { int x, y; int width, height; // in this case on the fly trasformation is way faster x = (int)(this.viewPort.Left + 20 * i); y = (int)(viewPort.Top + viewPort.Height /2 - v.Value / 2); width = 15; height = v.Value / 2; Rectangle rectangle = new Rectangle(x, y, width, height); g2.DrawRectangle(Pens.Black, rectangle); g2.FillRectangle(semiTransBrush, rectangle); g2.FillRectangle(Brushes.Cyan, rectangle); g2.DrawString(v.Key.ToString(), new Font(\u0026#34;Calibri\u0026#34;, 10.0f, FontStyle.Regular, GraphicsUnit.Pixel), semiTransBrush, new Point(x, y+v.Value/2)); i++; } g2.DrawString(\u0026#34;Min \u0026#34;, new Font(\u0026#34;Calibri\u0026#34;, 13.0f, FontStyle.Italic, GraphicsUnit.Pixel), semiTransBrush, new Point(this.viewPort.Left - 50, (viewPort.Top + viewPort.Height/2))); i = 0; foreach (var v in tuple.Item3) { int x, y; int width, height; // in this case on the fly trasformation is way faster x = (int)(this.viewPort.Left + 20 * i); y = (int)(viewPort.Top + viewPort.Height -30 - v.Value /2); width = 15; height = v.Value / 2; Rectangle rectangle = new Rectangle(x, y, width, height); g2.DrawRectangle(Pens.Black, rectangle); g2.FillRectangle(semiTransBrush, rectangle); g2.FillRectangle(Brushes.Cyan, rectangle); g2.DrawString(v.Key.ToString(), new Font(\u0026#34;Calibri\u0026#34;, 10.0f, FontStyle.Regular, GraphicsUnit.Pixel), semiTransBrush, new Point(x, y+v.Value/2)); i++; } g2.DrawString(\u0026#34;Max \u0026#34;, new Font(\u0026#34;Calibri\u0026#34;, 13.0f, FontStyle.Italic, GraphicsUnit.Pixel), semiTransBrush, new Point(this.viewPort.Left - 50, (viewPort.Top + viewPort.Height-30 ))); } Class for the generation and distribution calculus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public Tuple\u0026lt;Dictionary\u0026lt;double, int\u0026gt;, Dictionary\u0026lt;decimal, int\u0026gt;, Dictionary\u0026lt;decimal, int\u0026gt;\u0026gt; valueToDictionarys(int m, int n) { Dictionary\u0026lt;double, List\u0026lt;double\u0026gt;\u0026gt; randomvalues = new Dictionary\u0026lt;double, List\u0026lt;double\u0026gt;\u0026gt;(); int i = 0; int j = 0; decimal min; decimal max; //generation of random ditribution for (i = 0; i \u0026lt; m; i++) { List\u0026lt;Double\u0026gt; tmp = new List\u0026lt;double\u0026gt;(); for (j = 0; j \u0026lt; n; j++) tmp.Add(R.NextDouble()); randomvalues.Add(i, tmp); } Dictionary\u0026lt;double, int\u0026gt; randomdistrib = new Dictionary\u0026lt;double, int\u0026gt;(); Dictionary\u0026lt;decimal, int\u0026gt; minValues = new Dictionary\u0026lt;decimal,int\u0026gt;(); Dictionary\u0026lt;decimal, int\u0026gt; maxValues = new Dictionary\u0026lt;decimal, int\u0026gt;(); for (double k = 0.0; k \u0026lt;= 1.0000; k = k + 0.100) { foreach (var list in randomvalues) { foreach (var elem in list.Value) { if (elem \u0026gt;= k \u0026amp;\u0026amp; elem \u0026lt;= (k + 0.1)) { int tmp = 1; if (randomdistrib.TryGetValue(k, out tmp)) { randomdistrib.Remove(k); tmp++; } randomdistrib.Add(k, tmp); } } } } foreach (var list in randomvalues) { min = 1; max = 0; foreach (var elem in list.Value) { if ((decimal)elem \u0026lt; min) min =((decimal)( elem-(elem%0.01))); if ((decimal)elem \u0026gt; max) max = ((decimal)(elem - (elem % 0.01))); } int tmp2 = 1; if (minValues.TryGetValue(min, out tmp2)) { minValues.Remove(min); tmp2++; } minValues.Add(min, tmp2); tmp2 = 1; if (maxValues.TryGetValue(max, out tmp2)) { maxValues.Remove(max); tmp2++; } maxValues.Add(max, tmp2); } return new Tuple\u0026lt;Dictionary\u0026lt;double, int\u0026gt;, Dictionary\u0026lt;decimal, int\u0026gt;, Dictionary\u0026lt;decimal, int\u0026gt;\u0026gt;(randomdistrib, minValues, maxValues); } public void disegnaPaths(List\u0026lt;Strade\u0026gt; viewPortPaths) { for (int i = 0; i \u0026lt; viewPortPaths.Count; i++) { Pen pen = new Pen(Color.FromArgb(R.Next(0, 255), R.Next(0, 255), R.Next(0, 255))); for (int j = 0; j \u0026lt; viewPortPaths[i].getPath().Count - 1; j++) { g2.DrawLine(pen, (float)viewPortPaths[i].getPath()[j].X, (float)viewPortPaths[i].getPath()[j].Y, (float)viewPortPaths[i].getPath()[j + 1].X, (float)viewPortPaths[i].getPath()[j + 1].Y); } } } ","date":"2021-10-28T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/10_a/","title":"10_A"},{"content":"\n11_A assignament Request Discover a new important stochastic process by yourself! Consider the general scheme we have used so far to simulate some stochastic processes (such as the relative frequency of success in a sequence of trials, the sample mean and the random walk) and now add this new process to our simulator. Same scheme as previous program (random walk), except changing the way to compute the values of the paths at each time. Starting from value 0 at time 0, for each of m paths, at each new time compute N(i) = N(i-1) + Random step(i), for i = 1, \u0026hellip;, n, where Random step(i) is now a Bernoulli random variable with success probability equal to λ * (1/n) (where λ is a user parameter, eg. 50, 100, \u0026hellip;). At time n (last time) and one (or more) other chosen inner time 1\u0026lt;j\u0026lt;n (j is a program parameter) create and represent with histogram the distribution of N(i). Represent also the distributions of the following quantities (and any other quantity that you think of interest):\nDistance (time elapsed) of individual jumps from the origin Distance (time elapsed) between consecutive jumps (\u0026ldquo;holding times\u0026rdquo;) My Solution [Code in C#]https://github.com/yuky2020/Statistics-Pratical-LABS/tree/main/Assignment10/C%23/BernulliGraphics)\nThe part in disegna Grafici in witch i call the various usefull function 1 2 3 4 5 6 7 8 9 10 11 12 { distrubution = new BernulliPathfinder(n, m, lambda); disegnaPaths(fromPathstoViewport(distrubution.Get_paths(), viewPort)); disegnaHistogramma(viewPort, getDistribution(distrubution.Get_paths(), m / SCALE, j), n, j); disegnaHistogramma(viewPort, getDistribution(distrubution.Get_paths(), m / SCALE, n), n, n); //disegno le distanze disegnaDistanze(viewPort, individualJumpFromOriginD(distrubution.Get_paths()), 0, \u0026#34;Single jump distace \u0026#34;); disegnaDistanze(viewPort, doublejumpD(distrubution.Get_paths()), 80, \u0026#34;Double jump distance\u0026#34;); } the class for writing the histogram and for get the distribution are the same as the precedent hw so i will skip it,but bernulli pathfinder now work with lamba insted of p\nBernoulli pathfinder class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class BernulliPathfinder: Pathfinder { int m; //number of paths int n; //number of points double p; //probability public List\u0026lt;Strade\u0026gt; paths = new List\u0026lt;Strade\u0026gt;(); private Random R; public BernulliPathfinder(int n, int m, double p) { this.m = m; this.n = n; this.p = p; this.R = new Random(); for (int i=0; i \u0026lt; m; i++) { paths.Add(new Strade(createBernulliList())); } } private int bernoulli_Result(double p,int n) { double random_outcome = R.NextDouble(); if (random_outcome \u0026lt;= p/n) return 1; else return 0; } private List\u0026lt;double\u0026gt; createBernulliList() { List\u0026lt;double\u0026gt; bernoulli = new List\u0026lt;double\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { bernoulli.Add(bernoulli_Result(p, n)); } return bernoulli; } public List\u0026lt;Strade\u0026gt; Get_paths() { return this.paths; } } Disegna Distanze method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 private void disegnaDistanze(Rectangle viewPort, Dictionary\u0026lt;int, int\u0026gt; intervals, int offset, String text) { int i = 0; SolidBrush semiTransBrush = new SolidBrush(Color.FromArgb(128, 0, 0, 0)); foreach (var v in intervals) { int x, y; int width, height; // in this case on the fly trasformation is way faster x = (int)(this.viewPort.Left + 20 * i); y = (int)(viewPort.Top + viewPort.Height + offset); width = v.Value; height = viewPort.Height / intervals.Count; Rectangle rectangle = new Rectangle(x, y, width, height); g2.DrawRectangle(Pens.Black, rectangle); g2.FillRectangle(semiTransBrush, rectangle); g2.FillRectangle(Brushes.Violet, rectangle); g2.DrawString(v.Key.ToString(), new Font(\u0026#34;Calibri\u0026#34;, 10.0f, FontStyle.Regular, GraphicsUnit.Pixel), semiTransBrush, new Point(x, y)); i++; } g2.DrawString(text, new Font(\u0026#34;Calibri\u0026#34;, 13.0f, FontStyle.Italic, GraphicsUnit.Pixel), semiTransBrush, new Point(this.viewPort.Left - 140, (viewPort.Top + viewPort.Height + offset))); } Individual jump 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private Dictionary\u0026lt;int, int\u0026gt; individualJumpFromOriginD(List\u0026lt;Strade\u0026gt; strades) { Dictionary\u0026lt;int, int\u0026gt; dbj = new Dictionary\u0026lt;int, int\u0026gt;(); int i = 0; int tmp = 1; Boolean trov = false; foreach (Strade s in strades) { i = 0; tmp = 1; trov = false; while (!trov \u0026amp;\u0026amp; (i \u0026lt; s.getPath().Count() - 2)) { if (s.getPath()[i].Y != s.getPath()[i + 1].Y) trov = true; i++; } i++; if (dbj.TryGetValue(i, out tmp)) { dbj.Remove(i); dbj.Add(i, tmp + 1); } else dbj.Add(i, tmp); } return dbj; } Double jump 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private Dictionary\u0026lt;int, int\u0026gt; doublejumpD(List\u0026lt;Strade\u0026gt; strades) { Dictionary\u0026lt;int, int\u0026gt; dbj = new Dictionary\u0026lt;int, int\u0026gt;(); int i = 0; int tmp = 1; Boolean trov = false; foreach (Strade s in strades) { i = 0; tmp = 1; trov = false; while (!trov \u0026amp;\u0026amp; (i \u0026lt; s.getPath().Count() - 2)) { if (s.getPath()[i].Y != s.getPath()[i + 1].Y \u0026amp;\u0026amp; s.getPath()[i + 1].Y != s.getPath()[i + 2].Y) trov = true; i++; } i = i + 1; if (dbj.TryGetValue(i, out tmp)) { dbj.Remove(i); dbj.Add(i, tmp + 1); } else dbj.Add(i, tmp); } return dbj; } ","date":"2021-10-28T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/11_a/","title":"11_A"},{"content":"\n12_A assignament Request Discover one of the most important stochastic process by yourself !\nConsider the general scheme we have used so far to simulate stochastic processes (such as the relative frequency of success in a sequence of trials, the sample mean, the random walk, the Poisson point process, etc.) and now add this new process to our simulator.\nStarting from value 0 at time 0, for each of m paths, at each new time compute P(t) = P(t-1) + Random step(t), for t = 1, \u0026hellip;, n, where the Random step(t) is now:\nσ * sqrt(1/n) * Z(t),\nwhere Z(t) is a N(0,1) random variable (the \u0026ldquo;diffusion\u0026rdquo; σ is a user parameter, to scale the process dispersion).\nAt time n (last time) and one (or more) other chosen inner time 1\u0026lt;j\u0026lt;n (j is a program parameter) create and represent with histogram the distribution of P(t). Observe the behavior of the process for large n.\nMy Solution Code in C#\nIn Disiegnagrafici We graphicate the paths and the histograms as before but for sure now we use as a random step the new formula so i made a class WN graphicate ormalpaths and the histograms as before but for sure now we use as a random step the new formula so i made a class \u0026ldquo;NormalPathfinder\u0026rdquo; in witch i generate the list of value:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public NormalPathfinder(int n, int m) { this.m = n; this.n = m; this.p = 0.5; this.R = new Random(); for (int i=0; i \u0026lt; m; i++) { List\u0026lt;Double\u0026gt; list = createNormalList(); paths.Add(new Strade(list)); values.Add(list); } } private bool normal_Result(double p,out double ou) { double random_outcome =( R.NextDouble()+R.NextDouble()); double normal_distrbAtOut; double v = R.NextDouble(); //create a value between 1 and -1 random_outcome = random_outcome - 1; //get the standard normal for that point normal_distrbAtOut= Math.Pow(Math.E, (Math.Pow(-random_outcome, 2) / 2))/Math.Sqrt(2*Math.PI) ; //then use the other generated random if (v \u0026lt;= normal_distrbAtOut*Math.Sqrt(2*Math.PI)) { ou = random_outcome; return true; } else { ou = 0; return false; } } private List\u0026lt;double\u0026gt; createNormalList() { List\u0026lt;double\u0026gt; normal = new List\u0026lt;double\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { double j; if (normal_Result(p, out j)) normal.Add(j); else i--; } return normal; } Here we use create also the path with a Strade object :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //Dalla lista di valori passo ai punti ; public Strade(List\u0026lt;double\u0026gt; values) { this.values = values; double sqrt1n = (double)1 / values.Count; Math.Sqrt(sqrt1n); double jump=0; for (int i=0; i \u0026lt; values.Count; i++) { jump += (sqrt1n)*values[i]; path.Add(new PointF(i + 1, (float) jump)); } } ","date":"2021-10-28T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/12_a/","title":"12_A"},{"content":"\n13_A assignament Request Create a distribution representation (histogram, or CDF \u0026hellip;) to represent the following:\nRealizations taken from a Normal(0,1)\nRealizations of the mean, obtained by averaging several times (say m times, m large) n of the above realizations\nRealizations of the variance, obtained by averaging several times (say m times, m large) n of the above realizations\nRealizations taken from exp(N(0,1)))\nRealizations taken from N(0,1) squared\nRealizations taken from a (squared N(0,1)) divided by another (squared N(0,1))\nMy Solution Code in C#\nThe part in disegna Grafici in witch i call the various usefull function 1 2 disgnaIstogrammi(viewPort, valueToDictionarys(n, m, index13a)); valueToDictionarys disegnaIstogrami is the same method used before for graphicate 3 Dictionary. In valueToDictionry we use the before created Distribution (see 12A ) and based also on the actual type of dstribution that we need (1 normal N(0,1),exp(N(0,1),squared normal or 1 squared normal divided by another one ) to create the realization, the mean and variance distributions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 disgnaIstogrammi(viewPort, valueToDictionarys(n, m, index13a)); public Tuple\u0026lt;Dictionary\u0026lt;double, int\u0026gt;, Dictionary\u0026lt;decimal, int\u0026gt;, Dictionary\u0026lt;decimal, int\u0026gt;\u0026gt; valueToDictionarys(int m, int n, int index13a) { Dictionary\u0026lt;double, List\u0026lt;double\u0026gt;\u0026gt; randomvalues = new Dictionary\u0026lt;double, List\u0026lt;double\u0026gt;\u0026gt;(); int i = 0; int j = 0; //calcolation of the random ditribution for (i = 0; i \u0026lt; n; i++) { List\u0026lt;Double\u0026gt; tmp = new List\u0026lt;double\u0026gt;(); tmp = distrubution.values[i]; randomvalues.Add(i, tmp); } //controllo se è da fare exp squred o squared/ squared if (index13a != 0) { for (i = 0; i \u0026lt; n; i++) for (j = 0; j \u0026lt; m; j++) { if (index13a == 1) randomvalues[i][j] = Math.Pow(Math.E, randomvalues[i][j]); if (index13a == 2) randomvalues[i][j] = Math.Pow(randomvalues[i][j], 2); if (index13a == 3) randomvalues[i][j] = Math.Pow(randomvalues[i][j], 2); } if (index13a == 3) { NormalPathfinder distribution2 = new NormalPathfinder(n, m); Dictionary\u0026lt;double, List\u0026lt;double\u0026gt;\u0026gt; otherones = new Dictionary\u0026lt;double, List\u0026lt;double\u0026gt;\u0026gt;(); for (i = 0; i \u0026lt; n; i++) { List\u0026lt;Double\u0026gt; tmp = new List\u0026lt;double\u0026gt;(); tmp = distribution2.values[i]; otherones.Add(i, tmp); for (j = 0; j \u0026lt; m; j++) { otherones[i][j]= Math.Pow(otherones[i][j], 2); randomvalues[i][j] = randomvalues[i][j] / otherones[i][j]; } } } } Dictionary\u0026lt;double, int\u0026gt; randomdistrib = new Dictionary\u0026lt;double, int\u0026gt;(); Dictionary\u0026lt;decimal, int\u0026gt; meanValues = new Dictionary\u0026lt;decimal, int\u0026gt;(); Dictionary\u0026lt;decimal, int\u0026gt; varValues = new Dictionary\u0026lt;decimal, int\u0026gt;(); for (double k = -1.0; k \u0026lt;= 1.0000; k = k + 0.100) { foreach (var list in randomvalues) { foreach (var elem in list.Value) { if (elem \u0026gt; k \u0026amp;\u0026amp; elem \u0026lt;= (k + 0.1)) { int tmp = 1; if (randomdistrib.TryGetValue(k, out tmp)) { randomdistrib.Remove(k); tmp++; } randomdistrib.Add(k, tmp); } } } } foreach (var list in randomvalues) { double mean = 0; double variance = 0; foreach (var elem in list.Value) { mean = mean + (elem - mean); } foreach (var elem in list.Value) { variance = variance + ((elem - mean) * (elem - mean)); } mean = mean - (mean % 0.1); variance = variance - (variance % 2); int tmp2 = 1; if (meanValues.TryGetValue((decimal)mean, out tmp2)) { meanValues.Remove((decimal)mean); tmp2++; } meanValues.Add((decimal)mean, tmp2); tmp2 = 1; if (varValues.TryGetValue((decimal)variance, out tmp2)) { varValues.Remove((decimal)variance); tmp2++; } varValues.Add((decimal)variance, tmp2); } return new Tuple\u0026lt;Dictionary\u0026lt;double, int\u0026gt;, Dictionary\u0026lt;decimal, int\u0026gt;, Dictionary\u0026lt;decimal, int\u0026gt;\u0026gt;(randomdistrib, meanValues, varValues); } ","date":"2021-10-28T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/13_a/","title":"13_A"},{"content":"\n6_RA assignament Request Do a web research about the various methods proposed to compute the running median (one pass, online algorithms). Store (cite all sources and attributions) the algorithm(s) that you think is(are) a good candidate, explaining briefly how it works and possibly try a quick demo.\nCompute it with one pass the median is the value that is at the center of the distribution and biscet it,for computing it we can use a simple algo: Starting from a ordered distribution (cardinality n) whe could say that:\nif the number of value are odd we can take the value placed at (n+1)/2 as the median if the number of value is even we take the two value in the middle (at index n/2 and n/2+1) and compute the mean between the two value as the median how to calculate it with an oline algo we can approssimate the median with the formula: [1] Me= Xi+(Xi+1 -Xi)=(0,5 -Fi)/(Fi+1-Fi) where Fi are the acutual comulative frequency and calculate it online with this\nEfficient Algorithm for computing a Running Median From -LIGO- LASER INTERFEROMETER GRAVITATIONAL WAVE OBSERVATORY[2]\nInputs to the code: • X : the sequence x[k], k = 0, . . . , N − 1. • M : The number of points per block. Output of the code: • Y : sequence y[k], k = 0, . . . , N − M.\n1 Sort the first M samples x[k], k = 0, . . . , M −1, in ascending order. The ANSI C \u0026lt;stdlib.h\u0026gt; library comes with a routine for sorting called qsort which can be used for this first step. Let the sorted list, in ascending order, be Z[k], k = 0, . . . , M − 1. Thus, Z[0] ≤ Z[1] ≤ Z[2] . . . ≤ Z[M − 1].\n2 Load the sorted samples into the nodes of a linked list [6] with each node containing one sample. Each node of the linked list has three types of links to other nodes. Sequential link If the current node has sample x[p], then this link points to the node containing x[p + 1]. Next Sorted link If the current node has sample Z[p], then this link points to the node containing Z[p + 1]. Previous Sorted link If the current node has sample Z[p], then this link points to the node containing Z[p−1]. In the qsort algorithm, the ordering of equal samples is arbitrary and so is it assumed here.\n3 Set up an array, checks , of pointers to nodes of the linked list such that checks[n] points to the node containing Z h n ∗ floor ³√ M ´i. The special nodes pointed to by elements of checks are called checkpoints in the following. Further denote the samples contained in checkpoint p by C[p] = Z h p ∗ floor ³√ M ´i, p = 0, . . . , floor(√ M) − 1. Why are the checkpoints spaced √ M samples apart? Once one obtains a sorted block of M samples, the sequentially next sample outside this block must be placed in the sorted list and the sequentially first sample in the block must be deleted. This is done by first comparing the new sample sequentially against the samples 4 in checkpoints. Once the checkpoints that bracket the new sample are found, comparisons are made with only the samples within this bracket to locate the exact position of the new sample in the sorted list. This implies that in the worst case P comparison operations are needed, if P is the number of checkpoints used, to find the bracketing checkpoints. After this one may have to make M/P further comparisons to locate the exact position of the new sample in the ordered list. Thus the total operation count K, in the worst case, is K = P + M/P . (2) The value of P which minimises K is P = √ M. This is why checkpoints are spaced M/P = M/√ M = √ M samples apart in this algorithm.\n4 Find the element n0 of checks such that the sample in the corresponding node is nearest to the node containing the median (for M odd) or the first member of the pair which needs to be averaged (for M even). This element will provide a fast access to the node containing the samples needed to compute the median. This is necessary because we are dealing with a linked list and not an array that can be randomly accessed.\n5 FOR j = M TO N − 1 DO\n(a) Get sample x[j]. (b) Locate the element pj of checks such that C[pj ] ≤ x[j] \u0026lt; C[pj + 1]. (c) Start from the node checks[pj ] and follow the Next Sorted link until a node is found such that the sample value h it contains satisfies x[j] ≤ h. We have thus found the exact place where the new sample x[j] must be inserted. The next few steps find out the checkpoints that are bracketed by x[j] and the sample to be deleted, x[j − M]. When the corresponding nodes are respectively inserted and deleted from the list, the bracketed checlpoints must be shifted to adjacent nodes. (d) Consider the node containing the first element of the sequential list. That sample will be x[j − M]. (e) Find elements q and p of checks such that i. If x[j − M] \u0026lt; x[j] x(j − M) \u0026lt; C[q] \u0026lt; . . . \u0026lt; C[p] \u0026lt; x[j] ii. else if x[j − M] \u0026gt; x[j] x[j] \u0026lt; C[p + 1] \u0026lt; . . . \u0026lt; C[q] \u0026lt; x[j − M]. iii. else if x[j − M] == x[j] Do nothing. No shifting of checkpoints required since in this case all samples in the sorted list between x[j] and x[j − M] must be equal to x[j] = x[j − M]. (f) Shift the checkpoints found in step 5e. i. If x[j − M] \u0026lt; x[j] Shift each pointer checks[k], k ∈ [q, p], to point to the next right node (i.e., higher in sorted order). ii. Else shift to the next left node. (g) Delete node containing x[j − M] from the linked list (repair the links between the nodes adjacent to it). (h) Rewrite the data in this node by x[j]. (i) Insert this node before the node containing h. (j) Follow Next Sorted link from checks[n0] to get the median value. 6 END DO\nSeveral special cases may arise such as x[j] smaller or larger than any of the sample from the previous block. A lot of the code is devoted to handling such special cases.\n[1]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://dcc-backup.ligo.org/public/0027/T030168/000/T030168-00.pdf\" [2]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://it.wikipedia.org/wiki/Mediana_(statistica)#Definizione_e_calcolo\"\n","date":"2021-10-28T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/6_ra/","title":"6_RA"},{"content":"\n7_RA assignament Request Do a research about the random walk process and its properties. Compare your finding with your applications drawing your personal conclusions. Explain based on your exercise the beaviour of the distribution of the stochastic process (check out \u0026ldquo;Donsker\u0026rsquo;s invariance principle\u0026rdquo;). What are, in particular, its mean and variance at time n ?\nRandom walk process In mathematics, a random walk is a mathematical object, known as a stochastic or random process, that describes a path that consists of a succession of random steps on some mathematical space such as the integers.\nInteger random walk (1,-1) An elementary example of a random walk is the random walk on the integer number line,Z , which starts at 0 and at each step moves +1 or −1 with equal probability.[1]\nOther example Other examples include the path traced by a molecule as it travels in a liquid or a gas (see Brownian motion), the search path of a foraging animal, the price of a fluctuating stock and the financial status of a gambler: all can be approximated by random walk models, even though they may not be truly random in reality.[1]\nIn the 9A2 We have used the integer random walk in -1 1 and compared it with a standard normal ditribution (both moltiplicated by a fixed factor sqrt(1/n)) and with this comparison, by the histograms that rappresent the empiricals frequencies distribution,we could see that the two graphs are quite similar both with mean 0 and variance 1, this is in line with what stated by the Donsker\u0026rsquo;s invariance principle(functional central limit theorem)[2]\nFunctional central limit theorem the functional central limit theorem), named after Monroe D. Donsker, is a functional extension of the central limit theorem, state that: As random variables taking values in the Skorokhod space D[0,1], the random function W^n converges in distribution to a standard Brownian motion\nW:=(W(t)) with t in [0,1] and n-\u0026gt;∞ [1]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://en.wikipedia.org/wiki/Random_walk\" [2]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://en.wikipedia.org/wiki/Donsker%27s_theorem\"\n","date":"2021-10-28T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/7_ra/","title":"7_RA"},{"content":"\n8_A assignament Request Generate and represent m \u0026ldquo;sample paths\u0026rdquo; of n point each (m, n are program parameters), where each point represents a pair of: time index t, and relative frequency of success f(t),\nwhere f(t) is the sum of t Bernoulli random variables with distribution B(x, p) = p^x(1-p)^(1-x) observed at the various times up to t: j=1, \u0026hellip;, t..\nAt time n (last time) and one other chosen inner time 1\u0026lt;j\u0026lt;n (where j is a user parameter) represent with a histogram the distribution of f(t). See also what happens if you replace the relative frequency f(t) with the absolute frequency n(t) or by standard relative frequency: (f(t)-p) / sqrt(p(1-p)/t) [ or simply the \u0026ldquo;normalized\u0026rdquo; sum of bernoulli r.v.\u0026rsquo;s: n(t) / Math.sqrt(t) ].\nComment briefly on the convergence results you see.\nMy Solution Code in C#\nClass Main Form in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 public partial class BernulliGraphics : Form { public BernulliGraphics() { InitializeComponent(); contb = new Bitmap(755, 681); g2 = Graphics.FromImage(contb); comboBox1.SelectedIndex = 0; } Bitmap contb; Graphics g2; bool movable = false; bool resiable = false; // movable view port int contgleft = 0; int contgtop = 50; int contgwid = 400; int contgheight = 400; int mouseDeltax = 0; int mouseDeltay = 0; // window double minX_Window = 0; double maxX_Window = 400; double minY_Window = 0; double maxY_Window = 400; Rectangle viewPortc = new Rectangle(0, 50, 600, 600); private void button1_Click(object sender, EventArgs e) { creaGrafici(); } private void creaGrafici() { bool is_abs = false; if (comboBox1.SelectedIndex == 1) is_abs = true; int m = (int)this.numericUpDown1.Value; int n = (int)this.numericUpDown2.Value; double p = (double)this.numericUpDown3.Value / 100; int j = 40; double epsilon = (double)this.numericUpDown4.Value; DisegnaGrafici gr = new DisegnaGrafici(m, n, j, g2, p, epsilon, viewPortc, contgleft, contgtop, contgwid, contgheight, textBox1, textBox2,is_abs); gr.getGrapichs(); pictureBox2.Image = contb; } private void pictureBox2_MouseDown(object sender, MouseEventArgs e) { if ((e.Location.Y \u0026gt;= viewPortc.Top \u0026amp;\u0026amp; e.Location.Y \u0026lt;= (viewPortc.Top + viewPortc.Height)) \u0026amp;\u0026amp; (e.Location.X \u0026gt;= viewPortc.Left \u0026amp;\u0026amp; e.Location.X \u0026lt;= (viewPortc.Left + viewPortc.Width))) { if (e.Button == MouseButtons.Left) movable = true; if (e.Button == MouseButtons.Right) resiable = true; mouseDeltax = e.Location.X; mouseDeltay = e.Location.Y; } } private void pictureBox2_MouseLeave(object sender, EventArgs e) { resiable = false; movable = false; } private void pictureBox2_MouseMove(object sender, MouseEventArgs e) { if (movable == true) { contgleft = e.Location.X; contgtop = e.Location.Y; if (contgleft \u0026lt;= 0) contgleft = 0; if (contgtop \u0026lt;= 20) contgtop = 20; creaGrafici(); } if (resiable == true) { mouseDeltax = -mouseDeltax + e.Location.X; mouseDeltay = -mouseDeltay + e.Location.Y; contgwid += mouseDeltax / 40; contgheight += mouseDeltay / 40; creaGrafici(); } } private void pictureBox2_MouseUp(object sender, MouseEventArgs e) { resiable = false; movable = false; } private void comboBox1_SelectedIndexChanged(object sender, EventArgs e) { creaGrafici(); } } DisegnaGrafici class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 public class DisegnaGrafici { public Bitmap bitmap; public Graphics g2; public PictureBox pictureBox; private int SCALE = 10; private Random R = new Random(); public List\u0026lt;Strade\u0026gt; viewPortPaths; public List\u0026lt;Strade\u0026gt; viewPortAbsolute; private Rectangle viewPort; Matrix m1; BernulliPathfinder bernulli; public DisegnaGrafici(int m, int n, int j, Graphics graphics, double p, double epsilon, Rectangle vPort, int dinamicleft, int dinamictop, int contgw, int contgh, TextBox boxassfreq, TextBox boxrelfreq, bool is_abs) { this.g2 = graphics; this.viewPort = vPort; this.viewPort.X = dinamicleft; this.viewPort.Y = dinamictop; this.viewPort.Width = contgw; this.viewPort.Height = contgh; this.m1 = new Matrix(); g2.Clear(Color.Transparent); g2.FillRectangle(Brushes.Transparent, this.viewPort); g2.DrawRectangle(new Pen(Color.Black), this.viewPort); //genero la marice per le trasformazioni m1.Reset(); m1.Translate(-0, -(int)0, MatrixOrder.Append); m1.Scale((int)(viewPort.Width / (n - 0)), (int)(-viewPort.Height / (1 - 0)), MatrixOrder.Append); m1.Translate(viewPort.Left, viewPort.Top + viewPort.Height, MatrixOrder.Append); //genero le \u0026#34;strade\u0026#34; bernulli = new BernulliPathfinder(n, m, p); //disegno i vari path convertendoli per il viewport if (is_abs) disegnaABSPaths(fromPathstoAbsViewport(bernulli.paths, viewPort,n)); else { disegnaPaths(fromPathstoViewport(bernulli.paths, viewPort)); disegnaHistogramma(viewPort, getDistribution(bernulli.paths, m / SCALE, j), n, j); disegnaHistogramma(viewPort, getDistribution(bernulli.paths, m / SCALE, n), n, n); } getAbsoluteFrequencies(bernulli.paths, n, m, p, epsilon, boxassfreq, boxrelfreq); } private void disegnaABSPaths(List\u0026lt;List\u0026lt;PointF\u0026gt;\u0026gt; viewPortABSPaths) { for (int i = 0; i \u0026lt; viewPortABSPaths.Count; i++) { Pen pen = new Pen(Color.FromArgb(R.Next(0, 255), R.Next(0, 255), R.Next(0, 255))); for (int j = 0; j \u0026lt; viewPortABSPaths[i].Count - 1; j++) { g2.DrawLine(pen, (float)viewPortABSPaths[i][j].X, (float)viewPortABSPaths[i][j].Y, (float)viewPortABSPaths[i][j + 1].X, (float)viewPortABSPaths[i][j + 1].Y); } } } public List\u0026lt;List\u0026lt;PointF\u0026gt;\u0026gt; fromPathstoAbsViewport(List\u0026lt;Strade\u0026gt; paths, Rectangle viewPort,int n) { List\u0026lt;List\u0026lt;PointF\u0026gt;\u0026gt; viewPortAbsPaths = new List\u0026lt;List\u0026lt;PointF\u0026gt;\u0026gt;(); float tmpy = 0; float tmpx = 0; foreach (Strade path in paths) { tmpy = 0; tmpx = 0; List\u0026lt;PointF\u0026gt; abtmp = new List\u0026lt;PointF\u0026gt;(); foreach (int p in path.values) { if (p == 1) tmpy++; tmpx++; //only for graphic it rapidly abtmp.Add(new PointF(tmpx, (tmpy / n))); } PointF[] viewPortArrayPath = abtmp.ToArray(); this.m1.TransformPoints(viewPortArrayPath); viewPortAbsPaths.Add(viewPortArrayPath.ToList()); } return viewPortAbsPaths; } public void getAbsoluteFrequencies(List\u0026lt;Strade\u0026gt; paths, int n, int m, double p, double epsilon, TextBox boxassfreq, TextBox boxrelfreq) { Intervalli p_neighbourhood = new Intervalli(p - epsilon, p + epsilon); int absolute_frequency = 0; double relative_frequency = 0; foreach (Strade path in paths) { for (int i = 0; i \u0026lt; path.getPath().Count; i++) { if ( (path.getPath()[i].X == n) \u0026amp;\u0026amp; (path.getPath()[i].Y \u0026gt;= p_neighbourhood.LowerBound) \u0026amp;\u0026amp; (path.getPath()[i].Y \u0026lt; p_neighbourhood.UpperBound) ) { absolute_frequency++; } } } relative_frequency = (double)absolute_frequency / (double)m; boxassfreq.Text = absolute_frequency.ToString(); boxrelfreq.Text = relative_frequency * 100 + \u0026#34;%\u0026#34;; } public void disegnaPaths(List\u0026lt;Strade\u0026gt; viewPortPaths) { for (int i = 0; i \u0026lt; viewPortPaths.Count; i++) { Pen pen = new Pen(Color.FromArgb(R.Next(0, 255), R.Next(0, 255), R.Next(0, 255))); for (int j = 0; j \u0026lt; viewPortPaths[i].getPath().Count - 1; j++) { g2.DrawLine(pen, (float)viewPortPaths[i].getPath()[j].X, (float)viewPortPaths[i].getPath()[j].Y, (float)viewPortPaths[i].getPath()[j + 1].X, (float)viewPortPaths[i].getPath()[j + 1].Y); } } } public void disegnaHistogramma(Rectangle viewPort, List\u0026lt;Intervalli\u0026gt; intervals, int n, int j) { for (int i = 0; i \u0026lt; intervals.Count; i++) { int x, y; int width, height; // in this case on the fly trasformation is way faster x = (int)(this.viewPort.Left + this.viewPort.Width * (j) / n); y = (int)(viewPort.Top + viewPort.Height * ((100 - intervals[i].UpperBound * 100) / 100)); width = intervals[i].Counter; height = viewPort.Height / intervals.Count; Rectangle rectangle = new Rectangle(x, y, width, height); g2.DrawRectangle(Pens.Black, rectangle); SolidBrush semiTransBrush = new SolidBrush(Color.FromArgb(128, 150, 0, 0)); g2.FillRectangle(semiTransBrush, rectangle); g2.FillRectangle(Brushes.Violet, rectangle); } } public List\u0026lt;Intervalli\u0026gt; getDistribution(List\u0026lt;Strade\u0026gt; paths, int noIntervals, int j) { List\u0026lt;double\u0026gt; frequencies = new List\u0026lt;double\u0026gt;(); for (int i = 0; i \u0026lt; paths.Count; i++) { for (int k = 0; k \u0026lt; paths[i].getPath().Count; k++) { if (paths[i].getPath()[k].X == j) { frequencies.Add(paths[i].getPath()[k].Y); } } } List\u0026lt;Intervalli\u0026gt; intervals = new List\u0026lt;Intervalli\u0026gt;(); double intervalLength = 1.0 / (double)noIntervals; for (int i = 0; i \u0026lt; noIntervals; i++) { intervals.Add(new Intervalli(i * intervalLength, (i + 1) * intervalLength)); } for (int i = 0; i \u0026lt; intervals.Count; i++) { for (int k = 0; k \u0026lt; frequencies.Count; k++) { if ((frequencies[k] \u0026gt;= intervals[i].LowerBound) \u0026amp;\u0026amp; (frequencies[k] \u0026lt; intervals[i].UpperBound)) { intervals[i].Counter++; } } } return intervals; } public List\u0026lt;Strade\u0026gt; fromPathstoViewport(List\u0026lt;Strade\u0026gt; paths, Rectangle viewPort) { List\u0026lt;Strade\u0026gt; viewPortPaths = new List\u0026lt;Strade\u0026gt;(); foreach (Strade path in paths) { PointF[] viewPortArrayPath = path.getPath().ToArray(); this.m1.TransformPoints(viewPortArrayPath); viewPortPaths.Add(new Strade(viewPortArrayPath.ToList())); } return viewPortPaths; } public Graphics getGrapichs() { return this.g2; } } BernoulliPathfinder (Class with bernulli random variable creation methods) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class BernulliPathfinder { int m; //number of paths int n; //number of points double p; //probability public List\u0026lt;Strade\u0026gt; paths = new List\u0026lt;Strade\u0026gt;(); private Random R; public BernulliPathfinder(int n, int m, double p) { this.m = n; this.n = m; this.p = p; this.R = new Random(); for (int i=0; i \u0026lt; m; i++) { paths.Add(new Strade(createBernulliList())); } } private int bernoulli_Result(double p) { double random_outcome = R.NextDouble(); if (random_outcome \u0026lt;= p) return 1; else return 0; } private List\u0026lt;int\u0026gt; createBernulliList() { List\u0026lt;int\u0026gt; bernoulli = new List\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { bernoulli.Add(bernoulli_Result(p)); } return bernoulli; } } Strade.cs (path struct creation and useful methods) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class Strade { public List\u0026lt;PointF\u0026gt; path = new List\u0026lt;PointF\u0026gt;(); public List\u0026lt;int\u0026gt; values = new List\u0026lt;int\u0026gt;(); //Dalla lista di valori passo ai punti ; public Strade(List\u0026lt;int\u0026gt; values) { this.values = values; double mean = 0; for (int i=0; i \u0026lt; values.Count; i++) { if (i == 0) { mean = values[0]; } else { mean += (values[i] - mean) / (double)(i + 1); } path.Add(new PointF(i + 1, (float) mean)); } } public Strade(List\u0026lt;PointF\u0026gt; points) { path = points; } public List\u0026lt;double\u0026gt; getXs() { List\u0026lt;double\u0026gt; x_coordinates = new List\u0026lt;double\u0026gt;(); foreach (PointF p in this.getPath()) { x_coordinates.Add(p.X); } return x_coordinates; } public List\u0026lt;double\u0026gt; getYs() { List\u0026lt;double\u0026gt; y_coordinates = new List\u0026lt;double\u0026gt;(); foreach (PointF p in this.getPath()) { y_coordinates.Add(p.Y); } return y_coordinates; } public List\u0026lt;PointF\u0026gt; getPath() { return this.path; } public void setPath(List\u0026lt;PointF\u0026gt; path) { this.path = path; } } ","date":"2021-10-28T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/8_a/","title":"8_A"},{"content":"\n8_R assignament Request Do a research about the following topics:\nThe law of large numbers LLN, the various definitions of convergence\nThe convergence of the Binomial to the normal and Poisson distributions\nThe central limit theorem [in anticipation of a topic we will study later]\nThe Low of large numbers In probability theory, the law of large numbers (LLN) is a theorem that describes the result of performing the same experiment a large number of times. According to the law, the average of the results obtained from a large number of trials should be close to the expected value and will tend to become closer to the expected value as more trials are performed. There is two main forms of this law a weak and a strong one:\nWeak The weak law of large numbers (also called Khinchin\u0026rsquo;s law) states that the sample average converges in probability towards the expected value [1].\nWe have largly tested this with our work on the bernulli trials when we have see drowing the histograms that the frequencies tend to the probability the much more n is larger. Interpreting this result, the weak law states that for any nonzero margin specified (ε), no matter how small, with a sufficiently large sample there will be a very high probability that the average of the observations will be close to the expected value; that is, within the margin.\nUniform law of large numbers Suppose f(x,θ) is some function defined for θ ∈ Θ, and continuous in θ. Then for any fixed θ, the sequence {f(X1,θ), f(X2,θ), \u0026hellip;} will be a sequence of independent and identically distributed random variables, such that the sample mean of this sequence converges in probability to E[f(X,θ)]. This is the pointwise (in θ) convergence.[1]\nBorel\u0026rsquo;s low of large number Named after Emile Borel states that if an experiment is repated a large number of times,independently under identical conditions, then the proportion of times that any specified event occurs approximately equals the probability of the event\u0026rsquo;s occurrence on any particular trial; the larger the number of repetitions, the better the approximation tends to be. More precisely, if E denotes the event in question, p its probability of occurrence, and Nn(E) the number of times E occurs in the first n trials, then with probability one:\nNn(E)/N \u0026ndash;\u0026gt; p as n→∞\nStrong The strong law of large numbers (also called Kolmogorov\u0026rsquo;s law) states that the sample average converges almost surely to the expected value,(with almost sureley we mean with probability 1)\nThe convergence of the Binomial to the normal and Poisson dsistributions If n→∞ and p→0 while np approaches some positive number λ, then the binomial distribution approaches a Poisson distribution with expected value λ.\nIf n→∞ as p stays fixed, and X∼Binomial(n,p) then the distribution of (X−np)/√np(1-p) approaches the standard normal distribution, i.e. the normal distribution with expected value 0 and standard deviation 1.\nThe central limit theorem The central limit theorem state that when indipendent random variable are summed up their normalized sum tend to a normal distributions(beell curve) even when the original variable are not distribuited normaly(Lyapunov CLT[2]).\nIn other words we could say that given a poupulation and calculated the mean and the standard deviation,if we take a sufficiently large random samples from the population with replacement, then the distribution of the sample means will be approximately normally distributed and that this will hold true regardless of whether the source population is normal or skewed, provided the sample size is sufficiently large. In this week app this is particularly spottable in the realtive case,in fact when n increases,the convergence become centralIn this weak app this is particularly spottable eein the realtive case,in fact when n increases,the convergence become central.\n[1]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://en.wikipedia.org/wiki/Law_of_large_numbers#Weak_law\" [2]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://en.wikipedia.org/wiki/Central_limit_theorem#Lyapunov_CLT\"\n","date":"2021-10-28T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/8_r/","title":"8_R"},{"content":"\n9_A1 assignament Request Create a simulation with graphics to convince yourself of the pointwise convergence of the empirical CDF to the theoretical distribution (Glivenko-Cantelli theorem). Use a simple random variable of your chooice for such a demonstration.\nMy Solution Code in C#\nMethods for calculate empirical CDS in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public List\u0026lt;PointF\u0026gt; CDFtoViewport(Rectangle viewPort,int n) { List\u0026lt;PointF\u0026gt; cdfs=new List\u0026lt;PointF\u0026gt;(); List\u0026lt;int\u0026gt; values=new List\u0026lt;int\u0026gt;(); for (int i=0; i \u0026lt; n; i++) { values.Add(R.Next(149, 220)); } float tmpy = 0; float tmpx = -1; for (int i = 150; i \u0026lt;= 220; i = i + 5) { tmpy = 0; tmpx = tmpx + 1 ; foreach (int p in values) { if (p \u0026lt; i) tmpy++; //empirical CDF } cdfs.Add(new PointF(tmpx, tmpy/n)); } PointF[] viewPortArraycdf = cdfs.ToArray(); this.m2.TransformPoints(viewPortArraycdf); return(viewPortArraycdf.ToList()); } Method to draw both empirical and theorical rapresentation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private void disegnaCDFPaths(List\u0026lt;PointF\u0026gt; viewPortCDF) { Pen pen = new Pen(Color.Red); Pen pen2 = new Pen(Color.Green); //empirical cdf for (int j = 1; j \u0026lt; viewPortCDF.Count; j++) { g2.DrawLine(pen, (float)viewPortCDF[j-1].X, (float)viewPortCDF[j-1].Y, (float)viewPortCDF[j].X, (float)viewPortCDF[j].Y); g2.DrawEllipse(pen, new Rectangle((int)viewPortCDF[j].X, (int)viewPortCDF[j].Y, 4,4)); } //theorical cdf g2.DrawLine(pen2,(viewPort.Left+viewPort.Width), viewPort.Top, viewPort.Left, viewPort.Top+viewPort.Height); } 9_A2 assignament Request Generate sample paths of jump processes which at each time considered t = 1, \u0026hellip;, n perform jumps computed as:\nσ sqrt(1/n) R(t) where R(t) is a [-1,1] Rademacher random variable (https://en.wikipedia.org/wiki/Rademacher_distribution).\nσ sqrt(1/n) * Z(t), where Z(t) is a N(0,1) random variable (https://en.wikipedia.org/wiki/Normal_distribution)\nand see what happens as n (simulation parameter) becomes larger.\n[As before, at time n (last time) and one other chosen inner time 1\u0026lt;j\u0026lt;n (j is a program parameter) create and represent with histogram the distribution of the process ]\nMy Solution Code in C#\nInterface Pathfinder in C# 1 2 3 4 5 6 interface Pathfinder { abstract public List\u0026lt;Strade\u0026gt; Get_paths(); } Class Rademacher Pathfinder in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class RademacherPathfinder : Pathfinder { int m; //number of paths int n; //number of points double p; //probability public List\u0026lt;Strade\u0026gt; paths = new List\u0026lt;Strade\u0026gt;(); private Random R; public RademacherPathfinder(int n, int m) { this.m = n; this.n = m; this.p = 0.5; this.R = new Random(); for (int i=0; i \u0026lt; m; i++) { paths.Add(new Strade(createRademacherList())); } } private int rademacher_Result(double p) { double random_outcome = R.NextDouble(); if (random_outcome \u0026lt; p) return 1; else if (random_outcome == p) return 0; return -1; } private List\u0026lt;double\u0026gt; createRademacherList() { List\u0026lt;double\u0026gt; rademacher = new List\u0026lt;double\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { rademacher.Add(rademacher_Result(p)); } return rademacher; } public List\u0026lt;Strade\u0026gt; Get_paths() { return this.paths; } } Class Normal Pathfinder in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public class NormalPathfinder: Pathfinder { int m; //number of paths int n; //number of points double p; //probability public List\u0026lt;Strade\u0026gt; paths = new List\u0026lt;Strade\u0026gt;(); private Random R; public NormalPathfinder(int n, int m) { this.m = n; this.n = m; this.p = 0.5; this.R = new Random(); for (int i=0; i \u0026lt; m; i++) { paths.Add(new Strade(createNormalList())); } } private double normal_Result(double p) { double random_outcome = R.NextDouble(); double normal_distrbAtOut; double v = R.NextDouble(); //create a value between 1 and -1 random_outcome = random_outcome * 2 - 1; //get the standard normal for that point normal_distrbAtOut= Math.Pow(Math.E, (Math.Pow(-random_outcome, 2) / 2))/Math.Sqrt(2*Math.PI) ; //then use the other generated random if (v \u0026lt; normal_distrbAtOut) return random_outcome; else return 0; } private List\u0026lt;double\u0026gt; createNormalList() { List\u0026lt;double\u0026gt; normal = new List\u0026lt;double\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { normal.Add(normal_Result(p)); } return normal; } public List\u0026lt;Strade\u0026gt; Get_paths() { return this.paths; } } Disegna grafici class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 public class DisegnaGrafici { public Bitmap bitmap; public Graphics g2; public PictureBox pictureBox; private int SCALE = 4; private Random R = new Random(); public List\u0026lt;Strade\u0026gt; viewPortPaths; public List\u0026lt;Strade\u0026gt; viewPortAbsolute; private Rectangle viewPort; int n; Matrix m1; Matrix m2; Pathfinder distrubution; public DisegnaGrafici(int m, int n, int j, Graphics graphics, double epsilon, Rectangle vPort, int dinamicleft, int dinamictop, int contgw, int contgh, TextBox boxassfreq, TextBox boxrelfreq, bool is_abs,bool is_norml) { this.g2 = graphics; this.viewPort = vPort; this.viewPort.X = dinamicleft; this.viewPort.Y = dinamictop; this.viewPort.Width = contgw; this.viewPort.Height = contgh; this.n = n; this.m1 = new Matrix(); this.m2 = new Matrix(); g2.Clear(Color.Transparent); g2.FillRectangle(Brushes.Transparent, this.viewPort); g2.DrawRectangle(new Pen(Color.Black), this.viewPort); //genero la marice per le trasformazioni m1.Reset(); m1.Translate((float)-0, -(float)0, MatrixOrder.Append); m1.Scale((float)(viewPort.Width /m ), (float)(-viewPort.Height /1), MatrixOrder.Append); m1.Translate(viewPort.Left, viewPort.Top + viewPort.Height, MatrixOrder.Append); //Matrix for the cdf m2.Reset(); m2.Translate((float)-0, -(float)0, MatrixOrder.Append); m2.Scale((float)(viewPort.Width /14), (float)(-viewPort.Height / 1), MatrixOrder.Append); m2.Translate(viewPort.Left, viewPort.Top + viewPort.Height, MatrixOrder.Append); //genero le \u0026#34;strade\u0026#34; if (is_norml == false) distrubution = new RademacherPathfinder(n, m); else distrubution = new NormalPathfinder(n, m); //disegno i vari path convertendoli per il viewport if (is_abs) disegnaCDFPaths(CDFtoViewport(viewPort,n)); else { disegnaPaths(fromPathstoViewport(distrubution.Get_paths(), viewPort)); disegnaHistogramma(viewPort, getDistribution(distrubution.Get_paths(), m / SCALE, j), n, j); disegnaHistogramma(viewPort, getDistribution(distrubution.Get_paths(), m / SCALE, n), n, n); } getAbsoluteFrequencies(distrubution.Get_paths(), n, m, epsilon, boxassfreq, boxrelfreq); } private void disegnaCDFPaths(List\u0026lt;PointF\u0026gt; viewPortCDF) { Pen pen = new Pen(Color.Red); Pen pen2 = new Pen(Color.Green); //empirical cdf for (int j = 1; j \u0026lt; viewPortCDF.Count; j++) { g2.DrawLine(pen, (float)viewPortCDF[j-1].X, (float)viewPortCDF[j-1].Y, (float)viewPortCDF[j].X, (float)viewPortCDF[j].Y); g2.DrawEllipse(pen, new Rectangle((int)viewPortCDF[j].X, (int)viewPortCDF[j].Y, 4,4)); } //theorical cdf g2.DrawLine(pen2,(viewPort.Left+viewPort.Width), viewPort.Top, viewPort.Left, viewPort.Top+viewPort.Height); } public List\u0026lt;PointF\u0026gt; CDFtoViewport(Rectangle viewPort,int n) { List\u0026lt;PointF\u0026gt; cdfs=new List\u0026lt;PointF\u0026gt;(); List\u0026lt;int\u0026gt; values=new List\u0026lt;int\u0026gt;(); for (int i=0; i \u0026lt; n; i++) { values.Add(R.Next(149, 220)); } float tmpy = 0; float tmpx = -1; for (int i = 150; i \u0026lt;= 220; i = i + 5) { tmpy = 0; tmpx = tmpx + 1 ; foreach (int p in values) { if (p \u0026lt; i) tmpy++; //empirical CDF } cdfs.Add(new PointF(tmpx, tmpy/n)); } PointF[] viewPortArraycdf = cdfs.ToArray(); this.m2.TransformPoints(viewPortArraycdf); return(viewPortArraycdf.ToList()); } public void getAbsoluteFrequencies(List\u0026lt;Strade\u0026gt; paths, int n, int m, double epsilon, TextBox boxassfreq, TextBox boxrelfreq) { double p=0.5 ; Intervalli p_neighbourhood = new Intervalli(p - epsilon, p + epsilon); int absolute_frequency = 0; double relative_frequency = 0; foreach (Strade path in paths) { for (int i = 0; i \u0026lt; path.getPath().Count; i++) { if ( (path.getPath()[i].X == n) \u0026amp;\u0026amp; (path.getPath()[i].Y \u0026gt;= p_neighbourhood.LowerBound) \u0026amp;\u0026amp; (path.getPath()[i].Y \u0026lt; p_neighbourhood.UpperBound) ) { absolute_frequency++; } } } relative_frequency = (double)absolute_frequency / (double)m; boxassfreq.Text = absolute_frequency.ToString(); boxrelfreq.Text = relative_frequency * 100 + \u0026#34;%\u0026#34;; } public void disegnaPaths(List\u0026lt;Strade\u0026gt; viewPortPaths) { for (int i = 0; i \u0026lt; viewPortPaths.Count; i++) { Pen pen = new Pen(Color.FromArgb(R.Next(0, 255), R.Next(0, 255), R.Next(0, 255))); for (int j = 0; j \u0026lt; viewPortPaths[i].getPath().Count - 1; j++) { g2.DrawLine(pen, (float)viewPortPaths[i].getPath()[j].X, (float)viewPortPaths[i].getPath()[j].Y, (float)viewPortPaths[i].getPath()[j + 1].X, (float)viewPortPaths[i].getPath()[j + 1].Y); } } } public void disegnaHistogramma(Rectangle viewPort, List\u0026lt;Intervalli\u0026gt; intervals, int n, int j) { for (int i = 0; i \u0026lt; intervals.Count; i++) { int x, y; int width, height; // in this case on the fly trasformation is way faster x = (int)(this.viewPort.Left + this.viewPort.Width * (j) /n); y = (int)(viewPort.Top + viewPort.Height/2 * ((100 - (intervals[i].UpperBound) * 100) / 100)); width = intervals[i].Counter; height = viewPort.Height / intervals.Count; Rectangle rectangle = new Rectangle(x, y, width, height); g2.DrawRectangle(Pens.Black, rectangle); SolidBrush semiTransBrush = new SolidBrush(Color.FromArgb(128, 150, 0, 0)); g2.FillRectangle(semiTransBrush, rectangle); g2.FillRectangle(Brushes.Violet, rectangle); } } public List\u0026lt;Intervalli\u0026gt; getDistribution(List\u0026lt;Strade\u0026gt; paths, int noIntervals, int j) { List\u0026lt;double\u0026gt; frequencies = new List\u0026lt;double\u0026gt;(); for (int i = 0; i \u0026lt; paths.Count; i++) { for (int k = 0; k \u0026lt; paths[i].getPath().Count; k++) { if (paths[i].getPath()[k].X == j) { frequencies.Add(paths[i].getPath()[k].Y); } } } List\u0026lt;Intervalli\u0026gt; intervals = new List\u0026lt;Intervalli\u0026gt;(); double intervalLength = 1.0 / (double)noIntervals; for (int i= -noIntervals; i \u0026lt; noIntervals; i++) { intervals.Add(new Intervalli(i * intervalLength, (i + 1) * intervalLength)); } for (int i = 0; i \u0026lt; intervals.Count; i++) { for (int k = 0; k \u0026lt; frequencies.Count; k++) { if ((frequencies[k] \u0026gt;= intervals[i].LowerBound) \u0026amp;\u0026amp; (frequencies[k] \u0026lt; intervals[i].UpperBound)) { intervals[i].Counter++; } } } return intervals; } public List\u0026lt;Strade\u0026gt; fromPathstoViewport(List\u0026lt;Strade\u0026gt; paths, Rectangle viewPort) { List\u0026lt;Strade\u0026gt; viewPortPaths = new List\u0026lt;Strade\u0026gt;(); foreach (Strade path in paths) { PointF[] viewPortArrayPath = path.getPath().ToArray(); for (int i = 0;i \u0026lt; viewPortArrayPath.Length; i++) { viewPortArrayPath[i].Y= (viewPortArrayPath[i].Y + 1) / 2; } this.m1.TransformPoints(viewPortArrayPath); viewPortPaths.Add(new Strade(viewPortArrayPath.ToList())); } return viewPortPaths; } public Graphics getGrapichs() { return this.g2; } } ","date":"2021-10-28T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/9_a/","title":"9_A"},{"content":"\n9_R assignament Request History and derivation of the normal distribution. Touch, at least, the following three important perspectives, putting them into an historical context to understand how the idea developed:\nas approximation of binomial (De Moivre) as error curve (Gauss) as limit of sum of independent r.v.\u0026rsquo;s (Laplace) The normal distribution as approximation of binomial Historically, being able to compute binomial probabilities was one of the most important applications of the central limit theorem. Binomial probabilities with a small value for n (say, 20) were displayed in a table in a book. To calculate the probabilities with large values of n , you had to use the binomial formula, which could be very complicated. Using the normal approximation to the binomial distribution simplified the process. To compute the normal approximation to the binomial distribution, take a simple random sample from a population. You must meet the conditions for a binomial distribution:\nthere are a certain number n of independent trials the outcomes of any trial are success or failure each trial has the same probability of a success p Recall that if X is the binomial random variable, then X∼B(n,p) . The shape of the binomial distribution needs to be similar to the shape of the normal distribution. To ensure this, the quantities np and nq must both be greater than five ( np\u0026gt;5 and nq\u0026gt;5 ); the approximation is better if they are both greater than or equal to 10). Then the binomial can be approximated by the normal distribution with mean μ=np and standard deviation σ=√(npq) . Remember that q=1−p . In order to get the best approximation, add 0.5 to x or subtract 0.5 from x (use x+0.5 or x−0.5 ). The number 0.5 is called the continuity correction factor[1] As error Curve (Gauss) The normal distribution is also called Gaussian distribution in refers to Carl Friedrich Gauss, who first developed a two-parameter exponential function in 1809 in connection with studies of astronomical observation errors.This study led Gauss to formulate his law of observational error and to advance the theory of the method of least squares approximation.[4]\nWhen we look at a standardized Gaussian distribution in the so-called Normal Error Curve you can see that the probability of any one measurement being a member of this particular distribution increases as the magnitude of z increases.[2]\nas limit of sum of independent r.v.\u0026rsquo;s (Laplace) Laplace’s theorem states that if the error curve of a single observation is symmetric, then the error curve of the sum of several observations is indeed approximated by one of the Gaussian curves we have see before[3]. Hence if we take the further step of imagining that the error involved in an individual observation is the aggregate of a large number of “elementary” or “atomic” errors, then this theorem predicts that the random error that occurs in that individual observation is indeed controlled by De Moivre and Gauss’s curve, we call this the hypothesis of elementary errors\nBeyond errors The first mathematician to extend the provenance of the normal distribution beyond the distribution of measurement errors was Adolphe Quetelet (1796–1874). He began his career as an astronomer but then moved on to the social sciences. Consequently, he possessed an unusual combination of qualifications that placed him in just the right position for him to be able to make one of the most influential scientific observations of all times. He made in fact an analysis on the chest size of the Scottish soliders:\nGirth Frequency 33 3 34 18 35 81 36 185 37 420 38 749 39 1,073 40 1,079 41 934 42 658 43 370 44 92 45 50 46 21 47 4 48 1 With this analysis he find out that the pattern followed by the variety of its chest measurements was identical with that formed by the type of repeated measurements that are common in astronomy. In modern terminology, Quetelet claimed that the chest measurements were normally distributed!\n[1]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://stats.libretexts.org/Courses/Las_Positas_College/Math_40%3A_Statistics_and_Probability/06%3A_Continuous_Random_Variables_and_the_Normal_Distribution/6.04%3A_Normal_Approximatio### n_to_the_Binomial_Distribution\u0026rdquo; [2]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://chem.libretexts.org/Bookshelves/Analytical_Chemistry/Supplemental_Modules_(Analytical_Chemistry)/Analytical_Sciences_Digital_Library/JASDL/Courseware/Introduction_to_Signals_and_Noise/02_Signals_and_Noise/04_Normal_Error_Curve\" [3]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://www.maa.org/sites/default/files/pdf/upload_library/22/Allendoerfer/stahl96.pdf\"\n[4]\u0026ldquo;From Abraham De Moivre to Johann Carl Friedrich Gauss\u0026rdquo;,\u0026ldquo;http://www.ijesi.org/papers/Vol(7)i6/Version-5/D0706052834.pdf\"\n","date":"2021-10-28T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/9_r/","title":"9_R"},{"content":"\n5_RA assignament Request Do a web research about the various methods to generate, from a Uniform([0,1)), all the most important random variables (discrete and continuous). Collect all source code you think might be useful code of such algorithms (keep credits and attributions wherever applicable), as they will be useful for our next simulations.\nGenerate a bernulli distribution Various freamework include this distribution (for example Accord), and also some standard libraries like MathNet:\n1 2 3 4 5 6 public void GenerateChange(Point reference) { Bernoulli rBernoulli = new Bernoulli(0.5); double percentage = (rBernoulli.Sample() \u0026gt; 0.5 ? -1 : 1) * Simulation.Default.Data_Change_Maximum_Percentage * random.NextDouble(); GenerateChange(reference, percentage); } Or in pure c:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 #include \u0026lt;iostream\u0026gt; 2: #include \u0026lt;iomanip\u0026gt; 3: #include \u0026lt;chrono\u0026gt; 4: #include \u0026#34;ZZ.h\u0026#34; 5: using namespace std; 6: 7: typedef std::pair\u0026lt;ZZ_t*, ZZ_t*\u0026gt; QQ_t; 8: 9: // Computes the first n even absolute Bernoulli numbers 10: // B[0], B[2], B[4], ..., B[2*n - 2] for n \u0026gt;= 1. 11: QQ_t bernoulliT(int n) 12: { 13: /* assert(n \u0026gt; 0); */ 14: 15: ZZ_t g, num, den = ZZ_t(1), p = ZZ_t(1); 16: long k, j; 17: 18: ZZ_t* T = new ZZ_t[n]; 19: ZZ_t* N = new ZZ_t[n]; 20: ZZ_t* D = new ZZ_t[n]; 21: 22: N[0] = ZZ_t(1); 23: D[0] = ZZ_t(1); 24: 25: if (n == 1) return QQ_t(N, D); 26: 27: T[1] = ZZ_t(1); 28: 29: for (k = 2; k \u0026lt; n; k++) 30: { 31: T[k] = T[k - 1] * (k - 1); 32: } 33: 34: for (k = 2; k \u0026lt; n; k++) 35: { 36: for (j = k; j \u0026lt; n; j++) 37: { 38: T[j] = T[j - 1] * (j - k) + T[j] * (j - k + 2); 39: } 40: } 41: 42: for (k = 1; k \u0026lt; n; k++) 43: { 44: p *= 4; 45: den = p * (p - 1); 46: num = T[k] * (k + k); 47: g = gcd(num, den); 48: N[k] = num / g; 49: D[k] = den / g; 50: } 51: 52: delete[] T; 53: return QQ_t(N, D); 54: } 55: 56: // Computes the first n even absolute Bernoulli numbers 57: // B[0], B[2], B[4], ..., B[2*n - 2] for n \u0026gt;= 1. 58: QQ_t bernoulliS(int n) 59: { 60: /* assert(n \u0026gt; 0); */ 61: 62: ZZ_t g, den = ZZ_t(1), p = ZZ_t(1); 63: long h = 0, k, i, j = 1, tog = 1; 64: 65: ZZ_t* T = new ZZ_t[n]; 66: ZZ_t* N = new ZZ_t[n]; 67: ZZ_t* D = new ZZ_t[n]; 68: 69: N[0] = ZZ_t(1); 70: D[0] = ZZ_t(1); 71: 72: if (n == 1) return QQ_t(N, D); 73: 74: T[1] = ZZ_t(1); 75: 76: for (i = 3; i \u0026lt;= 2 * n; i++) 77: { 78: if (tog) 79: { 80: p *= 4; 81: den = (p - 1) * 2; 82: 83: for (k = h++; k \u0026gt; 0; k--) 84: T[k] += T[k + 1]; 85: } 86: else 87: { 88: for (k = 1; k \u0026lt;= h; k++) 89: T[k] += T[k - 1]; 90: 91: g = gcd(T[h], den); 92: N[j] = T[h] / g; 93: D[j++] = den / g; 94: } 95: tog = 1 - tog; 96: } 97: 98: delete [] T; 99: return QQ_t(N, D); 100: } 101: 102: int main() 103: { 104: int n = 500, i, rep; 105: pair\u0026lt;ZZ_t*, ZZ_t*\u0026gt; B; 106: 107: chrono::time_point\u0026lt;chrono::system_clock\u0026gt; start, end; 108: start = chrono::system_clock::now(); 109: 110: for (rep = 0; rep \u0026lt; 10; rep++) 111: { 112: B = bernoulliT(n); 113: } 114: 115: end = chrono::system_clock::now(); 116: chrono::duration\u0026lt;double\u0026gt; elapsed_seconds = end - start; 117: 118: cout \u0026lt;\u0026lt; \u0026#34;elapsed time: \u0026#34; \u0026lt;\u0026lt; elapsed_seconds.count() / rep 119: \u0026lt;\u0026lt; \u0026#34; seconds.\u0026#34; \u0026lt;\u0026lt; endl; 120: 121: ZZ_t* numer = B.first; 122: ZZ_t* denom = B.second; 123: 124: if (n \u0026lt; 100) 125: { 126: for (i = 0; i \u0026lt; n; i++) 127: { 128: cout \u0026lt;\u0026lt; \u0026#34;B[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34; 129: \u0026lt;\u0026lt; numer[i] \u0026lt;\u0026lt; \u0026#34;/\u0026#34; 130: \u0026lt;\u0026lt; denom[i] \u0026lt;\u0026lt; endl; 131: } 132: } 133: 134: delete [] numer; 135: delete [] denom; 136: 137: cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Done!\u0026#34; \u0026lt;\u0026lt; endl; 138: cin.get(); 139: 140: return 0; 141: } C# 1: using ZZ_t = System.Numerics.BigInteger; 2: using QQ_t = System.Tuple\u0026lt;System.Numerics.BigInteger, System.Numerics.BigInteger\u0026gt;; 3: 4: namespace WilliamHartChallenge 5: { 6: class Bernoulli 7: { 8: // Computes the first n even _absolute_ Bernoulli numbers. 9: // B[0], B[2], B[4], ..., B[2*n - 2] for n \u0026gt;= 1. 10: static QQ_t[] bernoulliT(int n) 11: { 12: // System.Diagnostics.Debug.Assert(n \u0026gt; 0); 13: 14: ZZ_t p = 1, g, den, num; 15: int k, j; 16: 17: var B = new QQ_t[n]; 18: var T = new ZZ_t[n]; 19: 20: B[0] = new QQ_t(1, 1); 21: if (n == 1) return B; 22: 23: T[1] = 1; 24: 25: for (k = 2; k \u0026lt; n; k++) 26: { 27: T[k] = (k - 1) * T[k - 1]; 28: } 29: 30: for (k = 2; k \u0026lt; n; k++) 31: { 32: for (j = k; j \u0026lt; n; j++) 33: { 34: T[j] = (j - k) * T[j - 1] + (j - k + 2) * T[j]; 35: } 36: } 37: 38: for (k = 1; k \u0026lt; n; k++) 39: { 40: p *= 4; 41: den = p * (p - 1); 42: num = (k + k) * T[k]; 43: g = gcd(num, den); 44: B[k] = new QQ_t(num / g, den / g); 45: } 46: 47: return B; 48: } 49: 50: // Computes the first n even _absolute_ Bernoulli numbers. 51: // B[0], B[2], B[4], ..., B[2*n - 2] for n \u0026gt;= 1. 52: static QQ_t[] bernoulliS(int n) 53: { 54: // System.Diagnostics.Debug.Assert(n \u0026gt; 0); 55: 56: ZZ_t p = 1, den = 0, g; 57: int h = 0, j = 1, k, i; 58: bool tog = true; 59: 60: var B = new QQ_t[n]; 61: var T = new ZZ_t[n]; 62: 63: B[0] = new QQ_t(1, 1); 64: if (n == 1) return B; 65: 66: T[1] = 1; 67: 68: for (i = 3; i \u0026lt;= 2 * n; i++) 69: { 70: if (tog) 71: { 72: p \u0026lt;\u0026lt;= 2; 73: den = (p - 1) \u0026lt;\u0026lt; 1; 74: 75: for (k = h++; k \u0026gt; 0; k--) 76: T[k] += T[k + 1]; 77: } 78: else 79: { 80: for (k = 1; k \u0026lt;= h; k++) 81: T[k] += T[k - 1]; 82: 83: g = gcd(T[h], den); 84: B[j++] = new QQ_t(T[h] / g, den / g); 85: } 86: tog = !tog; 87: } 88: 89: return B; 90: } 91: 92: static ZZ_t gcd(ZZ_t a, ZZ_t b) 93: { 94: ZZ_t x, y; 95: 96: if (a \u0026gt;= b) { x = a; y = b; } 97: else { x = b; y = a; } 98: 99: while (y != 0) 100: { 101: ZZ_t t = x % y; x = y; y = t; 102: } 103: 104: return x; 105: } 106: 107: static void Main() 108: { 109: int n = 100; 110: var B = bernoulliS(n); 111: 112: for (int i = 0; i \u0026lt; n; i++) 113: { 114: System.Console.WriteLine(i + \u0026#34; : \u0026#34; + B[i]); 115: } 116: 117: System.Console.WriteLine(\u0026#34;Done\u0026#34;); 118: System.Console.ReadLine(); 119: } 120: } 121: } Generate a binomial ditribution[7] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 #include \u0026#34;nmath.h\u0026#34; #include \u0026#34;dpq.h\u0026#34; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #define repeat for(;;) double rbinom(double nin, double pp) { /* FIXME: These should become THREAD_specific globals : */ static double c, fm, npq, p1, p2, p3, p4, qn; static double xl, xll, xlr, xm, xr; static double psave = -1.0; static int nsave = -1; static int m; double f, f1, f2, u, v, w, w2, x, x1, x2, z, z2; double p, q, np, g, r, al, alv, amaxp, ffm, ynorm; int i, ix, k, n; if (!R_FINITE(nin)) ML_WARN_return_NAN; r = R_forceint(nin); if (r != nin) ML_WARN_return_NAN; if (!R_FINITE(pp) || /* n=0, p=0, p=1 are not errors \u0026lt;TSL\u0026gt;*/ r \u0026lt; 0 || pp \u0026lt; 0. || pp \u0026gt; 1.)\tML_WARN_return_NAN; if (r == 0 || pp == 0.) return 0; if (pp == 1.) return r; if (r \u0026gt;= INT_MAX)/* evade integer overflow, and r == INT_MAX gave only even values */ return qbinom(unif_rand(), r, pp, /*lower_tail*/ 0, /*log_p*/ 0); /* else */ n = (int) r; p = fmin2(pp, 1. - pp); q = 1. - p; np = n * p; r = p / q; g = r * (n + 1); /* Setup, perform only when parameters change [using static (globals): */ /* FIXING: Want this thread safe -- use as little (thread globals) as possible */ if (pp != psave || n != nsave) { psave = pp; nsave = n; if (np \u0026lt; 30.0) { /* inverse cdf logic for mean less than 30 */ qn = R_pow_di(q, n); goto L_np_small; } else { ffm = np + p; m = (int) ffm; fm = m; npq = np * q; p1 = (int)(2.195 * sqrt(npq) - 4.6 * q) + 0.5; xm = fm + 0.5; xl = xm - p1; xr = xm + p1; c = 0.134 + 20.5 / (15.3 + fm); al = (ffm - xl) / (ffm - xl * p); xll = al * (1.0 + 0.5 * al); al = (xr - ffm) / (xr * q); xlr = al * (1.0 + 0.5 * al); p2 = p1 * (1.0 + c + c); p3 = p2 + c / xll; p4 = p3 + c / xlr; } } else if (n == nsave) { if (np \u0026lt; 30.0) goto L_np_small; } /*-------------------------- np = n*p \u0026gt;= 30 : ------------------- */ repeat { u = unif_rand() * p4; v = unif_rand(); /* triangular region */ if (u \u0026lt;= p1) { ix = (int)(xm - p1 * v + u); goto finis; } /* parallelogram region */ if (u \u0026lt;= p2) { x = xl + (u - p1) / c; v = v * c + 1.0 - fabs(xm - x) / p1; if (v \u0026gt; 1.0 || v \u0026lt;= 0.) continue; ix = (int) x; } else { if (u \u0026gt; p3) {\t/* right tail */ ix = (int)(xr - log(v) / xlr); if (ix \u0026gt; n) continue; v = v * (u - p3) * xlr; } else {/* left tail */ ix = (int)(xl + log(v) / xll); if (ix \u0026lt; 0) continue; v = v * (u - p2) * xll; } } /* determine appropriate way to perform accept/reject test */ k = abs(ix - m); if (k \u0026lt;= 20 || k \u0026gt;= npq / 2 - 1) { /* explicit evaluation */ f = 1.0; if (m \u0026lt; ix) { for (i = m + 1; i \u0026lt;= ix; i++) f *= (g / i - r); } else if (m != ix) { for (i = ix + 1; i \u0026lt;= m; i++) f /= (g / i - r); } if (v \u0026lt;= f) goto finis; } else { /* squeezing using upper and lower bounds on log(f(x)) */ amaxp = (k / npq) * ((k * (k / 3. + 0.625) + 0.1666666666666) / npq + 0.5); ynorm = -k * k / (2.0 * npq); alv = log(v); if (alv \u0026lt; ynorm - amaxp) goto finis; if (alv \u0026lt;= ynorm + amaxp) { /* stirling\u0026#39;s formula to machine accuracy */ /* for the final acceptance/rejection test */ x1 = ix + 1; f1 = fm + 1.0; z = n + 1 - fm; w = n - ix + 1.0; z2 = z * z; x2 = x1 * x1; f2 = f1 * f1; w2 = w * w; if (alv \u0026lt;= xm * log(f1 / x1) + (n - m + 0.5) * log(z / w) + (ix - m) * log(w * p / (x1 * q)) + (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / f2) / f2) / f2) / f2) / f1 / 166320.0 + (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / z2) / z2) / z2) / z2) / z / 166320.0 + (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / x2) / x2) / x2) / x2) / x1 / 166320.0 + (13860.0 - (462.0 - (132.0 - (99.0 - 140.0 / w2) / w2) / w2) / w2) / w / 166320.) goto finis; } } } L_np_small: /*---------------------- np = n*p \u0026lt; 30 : ------------------------- */ repeat { ix = 0; f = qn; u = unif_rand(); repeat { if (u \u0026lt; f) goto finis; if (ix \u0026gt; 110) break; u -= f; ix++; f *= (g / ix - r); } } finis: if (psave \u0026gt; 0.5) ix = n - ix; return (double)ix; } Poisson Ditribution more easy to compute than other:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # Include \u0026lt;stdio. h\u0026gt; # Include \u0026lt;math. h\u0026gt; # Include \u0026lt;time. h\u0026gt; Double U_Random (); Int possion (); Void main () { Double u = U_Random (); Int p = possion (); Printf (\u0026#34;% fn\u0026#34;, u ); Printf (\u0026#34;% dn\u0026#34;, p ); } Int possion ()/* generates a random number with a Poisson distribution. Lamda is the average number */ { Int Lambda = 20, k = 0; Long double p = 1.0; Long double l = exp (-Lambda);/* it is defined as long double for precision, and exp (-Lambda) is a decimal near 0 */ Printf (\u0026#34;%. 15Lfn\u0026#34;, l ); While (p\u0026gt; = l) { Double u = U_Random (); P * = u; K ++; } Return K-1; } Double U_Random ()/* generates a 0 ~ Random number between 1 */ { Double f; Srand (unsigned) time (NULL )); F = (float) (rand () % 100 ); /* Printf (\u0026#34;% fn\u0026#34;, f );*/ Return f/100; } [1]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://en.wikipedia.org/wiki/List_of_probability_distributions\" [2]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://www.cs.wm.edu/~va/software/park/park.html\" [3]https://www.johndcook.com/blog/2010/05/03/c-random-number-generation-code/ [4]https://homeweb.csulb.edu/~tebert/teaching/lectures/552/variate/variate.pdf [5]https://www.jstor.org/stable/1402590 [6]https://www.icosaedro.it/phplint/generating-statistical-distributions/index.html\n[7]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://svn.r-project.org/R/trunk/src/nmath/rbinom.c\"\n","date":"2021-10-23T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/5_ra/","title":"5_RA"},{"content":"\n6_R assignament Request Think and explain in your own words what is the role that probability plays in Statistics and the relation between the observed distribution and frequencies their \u0026ldquo;theoretical\u0026rdquo; counterparts. Do some practical examples where you explain how the concepts of an abstract probability space relate to more \u0026ldquo;concrete\u0026rdquo; and \u0026ldquo;real-world\u0026rdquo; objects when doing statistics.\nThe role of probability in statistic In statistcs when we talk about inference we move the contest from frequencies to a more interesting probability area, in this area we say for example that if a dice hit six with a frequencies of 1/6 (concrete) in the real world , we would have a probability of 1/6, note that probability is not about what happened, for if so then we do not need probability theory. Probability is about what may happen. [1]\nRelation between empircal case (distribution and frequencies) and theoretical starting from the same distribution let\u0026rsquo;try to analyze the two view:\nTheoretical distribution Empirical distribution Units Frequencies Units Probability X1 f1 X1 P1 Xn fn Xn Pm We could say so that frequency is an incarnation of probability, a realization in the real world of the abstract concept of probability and in this sense it\u0026rsquo;s easy to assume that the two fenomenus are goverend by the same law and that frequencies are just the actualization of the probability.\nIn inference statistics the objective is to determine which theta (we call it also states of nature) is the most probable so the one that can generate sample of empirical distribution (evidence) equivalent to the real one.\nThe methods of Bayesian inference You can never be certain about a hypothesis, but as the availability and dimension of data increases, the quality of the inference becomes better and better; with sufficient empirical evidence, it will become very high (for example, tending to 1) or very low (tending to 0). this represent a sort of implementation of the scientific method which normally involves the collection of data (empirical evidence), and hypothesis, here the hypothesis are the probability distributions that more rappresent the real fact.\nIn practice we have:\nP(θ|E) Where θ is the state of nature that can could be an array of values or a single value and E the evidence. So, referring to the frequencies, we have that for frequencies in an empirical contest we have that:\nFreq(X|Y)=Freq(X∧Y)/Freq(Y) Where X and Y are just labels and this is an identity. With\nP(X|Y)=P(X∧Y)/P(Y) we are in the realm of probability, so a branch of mathematics, and this is the definition for conditional probability.\n[1]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://math.stackexchange.com/questions/1443015/why-do-we-say-almost-surely-in-probability-theory\" [2]\u0026ldquo;url\u0026quot;\u0026ldquo;https://en.wikipedia.org/wiki/Probability_axioms\"\n","date":"2021-10-23T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/6_r/","title":"6_R"},{"content":"\n7_A assignament Request Given 2 variables from a csv compute and represent the statistical regression lines (X to Y and viceversa) and the scatterplot. Optionally, represent also the histograms on the \u0026ldquo;sides\u0026rdquo; of the chart (one could be draw vertically and the other one horizontally, in the position that you prefer). [Remember that all our charts must alway be done within \u0026ldquo;dynamic viewports\u0026rdquo; (movable/resizable rectangles). No third party libraries, to ensure ownership of creative process. May choose the language you prefer.].\nMy Solution Code in C#\nClass Main Form in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 public partial class Bivarianteform : Form { public Bivarianteform() { InitializeComponent(); contb = new Bitmap(755, 681); g2 = Graphics.FromImage(contb); } Dictionary\u0026lt;int, ElementoDisribuzione\u0026gt; csvContent = new Dictionary\u0026lt;int, ElementoDisribuzione\u0026gt;(); Distribuzione distr = new Distribuzione(); MediaCalOnline medie = new MediaCalOnline(); String[,] bivariantMatrix; List\u0026lt;String\u0026gt; attributename = new List\u0026lt;string\u0026gt;(); List\u0026lt;String\u0026gt; bivariante = new List\u0026lt;string\u0026gt;();//per ora poi diventera n variante; Bitmap contb; Graphics g2; List\u0026lt;PointF\u0026gt; points = new List\u0026lt;PointF\u0026gt;(); List\u0026lt;PointF\u0026gt; regressiony = new List\u0026lt;PointF\u0026gt;(); List\u0026lt;PointF\u0026gt; regressionx = new List\u0026lt;PointF\u0026gt;(); Matrix m = new Matrix(); Matrix m2 = new Matrix(); Matrix m3 = new Matrix(); int nr, nc; //Distributions SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt; firstdistr; SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt; seconddistr; bool movable = false; bool resiable = false; // movable view port int contgleft = 0; int contgtop = 50; int contgwid = 400; int contgheight = 400; int mouseDeltax=0; int mouseDeltay=0; // window double minX_Window = 0; double maxX_Window = 400; double minY_Window = 0; double maxY_Window = 400; Rectangle viewPortcontig=new Rectangle(0,50, 400, 400); private void button1_Click(object sender, EventArgs e) { var filePath = string.Empty; openFileDialog1.InitialDirectory = \u0026#34;c:\\\\\u0026#34;; openFileDialog1.Filter = \u0026#34;csv files (*.csv)|*.csv|All files (*.*)|*.*\u0026#34;; openFileDialog1.FilterIndex = 2; openFileDialog1.RestoreDirectory = true; if (openFileDialog1.ShowDialog() == DialogResult.OK) { //Get the path of specified file filePath = openFileDialog1.FileName; //Read the contents of the file into a stream using (TextFieldParser csvParser = new TextFieldParser(filePath)) { csvParser.CommentTokens = new string[] { \u0026#34;#\u0026#34; }; csvParser.SetDelimiters(new string[] { \u0026#34;,\u0026#34; }); csvParser.HasFieldsEnclosedInQuotes = true; // Save the row with the column names string[] fieldsNames = csvParser.ReadFields(); attributename.AddRange(fieldsNames); int i = 0; while (!csvParser.EndOfData) { // Read current line fields, pointer moves to the next line. string[] fields = csvParser.ReadFields(); ElementoDisribuzione elem = new ElementoDisribuzione(fields[0]); int j = 0; foreach (String field in fields) { if (!String.IsNullOrEmpty(field)) { double tmp; if (Double.TryParse(field, out tmp)) { elem.setVariable(fieldsNames[j], new Tuple\u0026lt;Object, Type\u0026gt;(tmp, tmp.GetType())); medie.addAttribute(fieldsNames[j], tmp); } else elem.setVariable(fieldsNames[j], new Tuple\u0026lt;Object, Type\u0026gt;(field, field.GetType())); } j++; } csvContent.Add(i, elem); distr.addElementoDef(elem); i++; } } button2.Visible = true; } } private void button2_Click(object sender, EventArgs e) { ; foreach (var elem in attributename) contextMenuStrip1.Items.Add(elem); contextMenuStrip1.Visible = true; } private void contextMenuStrip1_Opening(object sender, CancelEventArgs e) { } private void contextMenuStrip1_ItemClicked(object sender, ToolStripItemClickedEventArgs e) { bivariante.Add(e.ClickedItem.Text); button2.Visible = false; foreach (var elem in attributename) contextMenuStrip2.Items.Add(elem); contextMenuStrip2.Visible = true; } private void contextMenuStrip2_ItemClicked(object sender, ToolStripItemClickedEventArgs e) { bivariante.Add(e.ClickedItem.Text); double mediax = 0; double mediay = 0; double sigmax2=0; double sigmay2=0; double sigmaxy=0; bool isDouble = false; List\u0026lt;Double\u0026gt; valuesx = new List\u0026lt;double\u0026gt;(0); List\u0026lt;Double\u0026gt; valuesy = new List\u0026lt;double\u0026gt;(0); medie.getMedia(bivariante.ElementAt(0), out mediax); //se la media è diversa da zero sono sicuro che è double medie.getMedia(bivariante.ElementAt(1), out mediay); if (mediax != 0) { if (mediay != 0) { isDouble = true; Tuple\u0026lt;Object, Type\u0026gt; tmp; foreach (var elm in csvContent.Values) { elm.getVariable(bivariante.ElementAt(0), out tmp); valuesx.Add((double)tmp.Item1); elm.getVariable(bivariante.ElementAt(1), out tmp); valuesy.Add((double)tmp.Item1); } medie.getdDeviation2(bivariante.ElementAt(0), valuesx, out sigmax2); distr.getdistribuzioneN(bivariante.ElementAt(0), out firstdistr); medie.getdDeviation2(bivariante.ElementAt(1), valuesy, out sigmay2); distr.getdistribuzioneN(bivariante.ElementAt(1), out seconddistr); medie.getbivariantDeviation(bivariante.ElementAt(0), bivariante.ElementAt(1), valuesx,valuesy, out sigmaxy); for (int i = 0; i \u0026lt;= maxX_Window; i++) { regressionx.Add(new PointF(i, (float) (((sigmaxy / sigmax2) * (i - mediax)) + mediay))); } for (int i = 0; i \u0026lt;= maxY_Window; i++) { regressiony.Add(new PointF((float)(((sigmaxy / sigmay2) * (i - mediay)) + mediax), i)); } } } bivariantMatrix = distr.getbivariantmatrix(bivariante, csvContent.Values, out nr, out nc); this.button3.Visible = true; } private void button3_Click(object sender, EventArgs e) { creaGrafici(); } private void creaGrafici() { foreach (var elem in csvContent) { Tuple\u0026lt;Object, Type\u0026gt; a, b; float x, y; elem.Value.getVariable(bivariante.ElementAt(0), out a); elem.Value.getVariable(bivariante.ElementAt(1), out b); x = (float)(double)a.Item1; y = (float)(double)b.Item1; points.Add(new PointF(x, y)); } //contingency createconting(g2, 0, 50,400,400); } private void createconting(Graphics g2, int dinamicleft, int dinamictop,int contgw,int contgh) { viewPortcontig.X = dinamicleft; viewPortcontig.Y = dinamictop; viewPortcontig.Width = contgw; viewPortcontig.Height = contgh; //viewPortcontig.Location= new Point(viewPortcontig.Location.X+dinamicleft,viewPortcontig.Location.Y+dinamictop); g2.Clear(BackColor); g2.FillRectangle(Brushes.White, viewPortcontig); // window drow g2.DrawLine(new Pen(Color.Black, 2), viewPortcontig.X, viewPortcontig.Y, viewPortcontig.X, (viewPortcontig.Y + viewPortcontig.Height)); g2.DrawLine(new Pen(Color.Black, 2), viewPortcontig.X, (viewPortcontig.Y + viewPortcontig.Height), (viewPortcontig.X + viewPortcontig.Width), (viewPortcontig.Y + viewPortcontig.Height)); m.Reset(); m.Translate(-(int)minX_Window, -(int)minY_Window, MatrixOrder.Append); m.Scale((int)(viewPortcontig.Width / (maxX_Window - minX_Window)), (int)(-viewPortcontig.Height / (maxY_Window - minY_Window)), MatrixOrder.Append); m.Translate(viewPortcontig.Left, viewPortcontig.Top + viewPortcontig.Height, MatrixOrder.Append); PointF[] myPoints = points.ToArray(); PointF[] myPointsreal = points.ToArray(); PointF[] pRegressionx = regressionx.ToArray(); PointF[] pRegressiony = regressiony.ToArray(); int i = 0; m.TransformPoints(myPoints); m.TransformPoints(pRegressionx); m.TransformPoints(pRegressiony); foreach (PointF punto in myPoints) { if (myPointsreal[i].X \u0026lt;= maxX_Window \u0026amp;\u0026amp; myPointsreal[i].Y \u0026lt;= maxY_Window) { g2.FillEllipse(Brushes.Black, new Rectangle(new Point((int)(punto.X - 2), (int)(punto.Y - 2)), new Size(4, 4))); g2.DrawString(myPointsreal[i].ToString(), new Font(\u0026#34;Arial\u0026#34;, 10), Brushes.Black, (int)(punto.X), (int)(punto.Y)); g2.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(punto.X - 2), (int)(viewPortcontig.Y + viewPortcontig.Height - 2)), new Size(4, 4))); g2.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(viewPortcontig.X), (int)(punto.Y - 2)), new Size(4, 4))); } i++; ; } foreach (PointF punto in pRegressionx) { g2.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(punto.X - 2), (int)(punto.Y - 2)), new Size(4, 4))); } foreach (PointF punto in pRegressiony) { g2.FillEllipse(Brushes.Green, new Rectangle(new Point((int)(punto.X - 2), (int)(punto.Y - 2)), new Size(4, 4))); } pictureBox2.Image = contb ; } private void pictureBox2_MouseDown(object sender, MouseEventArgs e) { if ( (e.Location.Y\u0026gt;=viewPortcontig.Top \u0026amp;\u0026amp;e.Location.Y \u0026lt;= (viewPortcontig.Top+viewPortcontig.Height))\u0026amp;\u0026amp;(e.Location.X \u0026gt;= viewPortcontig.Left \u0026amp;\u0026amp; e.Location.X \u0026lt;= (viewPortcontig.Left + viewPortcontig.Width))) { if (e.Button == MouseButtons.Left) movable = true; if (e.Button == MouseButtons.Right) resiable = true; mouseDeltax = e.Location.X; mouseDeltay = e.Location.Y; } } private void pictureBox2_MouseLeave(object sender, EventArgs e) { resiable = false; movable = false; } private void pictureBox2_MouseMove(object sender, MouseEventArgs e) { if (movable == true) { contgleft = e.Location.X; contgtop = e.Location.Y; if (contgleft \u0026lt;= 0) contgleft = 0; if (contgtop \u0026lt;= 20) contgtop = 20; createconting(g2, contgleft, contgtop, contgwid, contgheight); } if (resiable == true) { mouseDeltax = -mouseDeltax + e.Location.X ; mouseDeltay = -mouseDeltay + e.Location.Y; contgwid += mouseDeltax/40; contgheight += mouseDeltay/40; createconting(g2, contgleft, contgtop, contgwid, contgheight); } } private void pictureBox2_MouseUp(object sender, MouseEventArgs e) { resiable = false; movable = false; } } } ","date":"2021-10-23T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/7_a/","title":"7_A"},{"content":"\n7_R assignament Request Explain the Bayes Theorem and its key role in statistical induction. Describe the different paradigs that can be found within statistical inference (such as\u0026quot;bayesian\u0026quot;, \u0026ldquo;frequentist\u0026rdquo; [Fisher, Neyman]).\nThe Bayes Theorem Bayes\u0026rsquo; theorem is used to calculate the probability of a cause that triggered the occurred event, and the importance of this theorem for statistics is such that different interpretation and usage divided the statisticians into two schools Bayesian and Frequentist\nP(A|B)=(P(B|A)P(A))/P(B)\nFrequentist and Bayesian statistics we called this therm prior probability.\nFrequentist According to the frequentist definition of probability, only repeatable random events (like a dice rool) have probabilities. These probabilities are equal to the long-term frequency of occurrence of the events in question. Frequentists don’t attach probabilities to hypotheses or to any fixed but unknown values in general. [1] Basically, a frequentist method makes predictions on the underlying truths of the experiment using only data from the current experiment.\nBayesian Bayesians view probabilities as a more general concept a Bayesian can use probabilities to represent the uncertainty in any event or hypothesis. [1]\nStatistical infernce paradigm So, the biggest distinction is that Bayesian probability specifies that there is some prior probability. The division between the two schools of thought occurs because of the term P(B) (P(θ) in the classroom)\nThe Frequentist The Bayesian chose to ignore the term and assign it a uniform distribution choose to use a certain already calculated shape distribution(like bernulli etc..) [1]\u0026ldquo;url\u0026rdquo;,\u0026ldquo;https://en.wikipedia.org/wiki/Bayes%27_theor\"\n","date":"2021-10-23T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/7_r/","title":"7_R"},{"content":"\n4_RA assignament Request Do a personal research about the real world window to viewport transformation, and note separately the formulas and code which can be useful for your present and future applications.\nreal world to viewport When we want to drow a chart in .net we need to address the problem of rappresenting points inside a pictureBox(often inside a rectangle), for do this we need to operate some trasformation, we can do this one by one, or create a trasformation matrix and use this on every point. The matrix is for sure more rapid,and functional,so let\u0026rsquo;s look in depth how it works:\nTraformation Matrix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //Frist we need to create a matrix Matrix m = new Matrix(); //----- // then we need to prepare the needed trasformation m.Translate(-(int)minX_Window,-(int)minY_Window,MatrixOrder.Append); m.Scale( (int)(viewPort.Width / (maxX_Window - minX_Window)),(int)(-viewPort.Height / (maxY_Window - minY_Window)), MatrixOrder.Append); m.Translate(viewPort.Left, viewPort.Top + viewPort.Height, MatrixOrder.Append); // we apply the trasformation to the array of points that we need in the graphics m.TransformPoints(myPoints ); // in the end we can write the point to the graphics (THIS IS AN EXAMPLE FROM MY IMPLEMENTATION) foreach(PointF punto in myPoints) { if (myPointsreal[i].X \u0026lt;= maxX_Window \u0026amp;\u0026amp; myPointsreal[i].Y \u0026lt;= maxY_Window) { g.FillEllipse(Brushes.Black, new Rectangle(new Point((int)(punto.X - 2), (int)(punto.Y - 2)), new Size(4, 4))); g.DrawString(myPointsreal[i].ToString(), new Font(\u0026#34;Arial\u0026#34;, 10), Brushes.Black,(int)(punto.X), (int)(punto.Y)); g.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(punto.X - 2), (int)(viewPort.Y + viewPort.Height - 2)), new Size(4, 4))); g.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(viewPort.X), (int)(int)(punto.Y - 2)), new Size(4, 4))); } } ","date":"2021-10-18T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/4_ra/","title":"4_RA"},{"content":"\n5_R assignament Request Explain a possibly unified conceptual framework to obtain all most common measures of central tendency and of dispersion using the concept of distance (or \u0026ldquo;premetric\u0026rdquo;, or similarity in general). Discuss why it is useful to discuss these concepts introducing the notion of distance. Finally, point out the difference between the mathematical definition of \u0026ldquo;distance\u0026rdquo; and the properties of the \u0026ldquo;premetrics\u0026rdquo; useful in statistics, pointing out trhe most important distances, indexes and similarity measures used in statistics, data analysis and machine learning (such as for instance; Mahalanobis distance, Euclidean distance, Minkowski distance, Manhattan distance, Hamming distance, Cosine distance, Chebishev distance, Jaccard index, Haversine distance, Sørensen-Dice index, etc.).\nCentral tendency In statistics, a central tendency (or measure of central tendency) is a typical or central value for a probability distribution [2] also called a center or location of the distribution. nevertheless measures of central tendency are often called averages.\ncommon measures of central tendency are the arithmetic mean, the median, and the mode. A middle tendency can be calculated for either a finite set of values or for a theoretical distribution, such as the normal distribution. Occasionally authors use central tendency to denote “the tendency of quantitative data to cluster around some central value.” The central tendency of a distribution is typically contrasted with its dispersion or variability; dispersion and central tendency are the often characterized properties of distributions. Analysis may judge whether data has a strong or a weak central tendency based on its dispersion. In statistics, probability theory, and information theory, a statistical distance quantifies the distance between two statistical objects, which can be two random variables, or two probability distributions or samples, or the distance can be between an individual sample point and a population or a wider sample of points.[3]\nArithmetic Mean: In mathematics and statistics, the arithmetic mean or simply the mean or the average (when the context is clear), is the sum of a collection of numbers divided by the count of numbers in the collection. For sure we can also use is online implementation fon fast computation but the meaning remain the same,[2]\nMedian: the median of a population is any value such that at most half of the population is less than the proposed median and at most half is greater than the proposed median.Medians may not be unique. If each set contains less than half the population, then some of the population is exactly equal to the unique median[4].\nThe median is well-defined for any ordered (one-dimensional) data, and is independent of any distance metric. The median can thus be applied to classes which are ranked but not numerical (e.g. working out a median grade when students are graded from A to F), although the result might be halfway between classes if there is an even number of cases.\nMode: The mode of a sample is the element that occurs most often in the collection. For example, the mode of the sample [1,3, 3, 3, 3, 5, 7, 7, 20, 30, 50 is 3. Given the list of data [1, 1, 2, 4, 4] the mode is not unique – the dataset may be said to be bimodal, while a set with more than two modes may be described as multimodal.Usualy in the bimodal case we take as the mode the avreage of the two mode if is possible, infact unlike mean and median, the concept of mode also makes sense for “nominal data” (i.e., not consisting of numerical values in the case of mean, or even of ordered values in the case of median).\nDispersion: percentiles and standard deviations Several measures of dispersion include range,standard deviations and quantiles, in general we can say that dispersion is the size of distribution of values in a data set.\nBased on the mean, the standard deviation It’s a measure of how far each observed value is from the mean in a data set usualy deviation will be represented by the lower case Greek letter sigma (σ). Can be used when the distribution of data is rappresentable as a normal distribution, and is used to determine whether a particular data point is in standard or unusual range. The more devieted a data point is from the mean, the more “unusual” that data point is. A low value for the standard deviation means that most of the data are around the mean,while a high value means that the data are spread over a wider range of values.[7]\nQuantiles Quantiles can be applied to any continuous data set, a quantile divides a data set in continuos distribution made of equal proportions and represents the proportion of data at any point; the most used quantiles are:\nQuartiles: dataset diveded in 4 quarters. Quintiles: dataset is divided in 5 Percentiles: dataset is divided into 100 we can for sure also extract the median from the quantiles for ex: the 50th percentile and the 3 quintiles is the median. Distance Distance is a numerical measurement of how far apart objects or points are. In mathematics, a distance function or metric is a generalization of the concept of physical distance; it is a way of describing what it means for elements of some space to be “close to”, or “far away from” each other.[6]\nIn the Euclidean space Rn, the distance between two points is usually given by the Euclidean distance (2-norm distance); but Euclidean distance could be extended also to n-space, and become usefull also in other field as ML and biometrics(Algorithm like HOG: my implementation); the infinity version is called also Chebyshev distance. Other distances, based on other norms, are sometimes usefull like the Minkowski distance(of various order p (p-norm distance))\n[1] \u0026ldquo;https://en.wikipedia.org/wiki/Arithmetic_mean \u0026quot; [2]\u0026ldquo;https://en.wikipedia.org/wiki/Statistical_distance \u0026quot; [3]\u0026ldquo;https://en.wikipedia.org/wiki/Central_tendency \u0026quot; [4]\u0026ldquo;https://en.wikipedia.org/wiki/Median \u0026quot; [5]\u0026ldquo;https://en.wikipedia.org/wiki/Mode_(statistics) \u0026quot; [6]\u0026ldquo;https://it.wikipedia.org/wiki/Distanza_(matematica) \u0026quot;\n","date":"2021-10-18T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/5_r/","title":"5_R"},{"content":"\n6_A assignament Request Prepare separately the following charts: 1) Scatterplot, 2) Histogram/Column chart [in the histogram, within each class interval, draw also a vertical colored line where lies the true mean of the observations falling in that class] and 3) Contingency table, using the graphics object and its methods (Drawstring(), MeasureString(), DrawLine(), etc). Use them to represent 2 numerical variables that you select from a CSV file. In particular, in the same picture box, you will make at least 2 separate charts: 1 dynamic rectangle will contain the contingency table, and 1 rectangle (chart) will contain the scatterplot, with the histograms/column charts and rug plots drawn respectively near the two axis (and oriented accordingly)\nMy Solution Code in C#\nClass Main Form in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 public partial class Bivarianteform : Form { public Bivarianteform() { InitializeComponent(); b = new Bitmap(755,681); g = Graphics.FromImage(b); contb = new Bitmap(739,668); g2 = Graphics.FromImage(contb); } Dictionary\u0026lt;int, ElementoDisribuzione\u0026gt; csvContent = new Dictionary\u0026lt;int, ElementoDisribuzione\u0026gt;(); Distribuzione distr = new Distribuzione(); MediaCalOnline medie = new MediaCalOnline(); String[,] bivariantMatrix; List\u0026lt;String\u0026gt; attributename = new List\u0026lt;string\u0026gt;(); List\u0026lt;String\u0026gt; bivariante = new List\u0026lt;string\u0026gt;();//per ora poi diventera n variante; Bitmap b; Bitmap contb; Graphics g2; Graphics g; Matrix m = new Matrix(); Matrix m2 = new Matrix(); Matrix m3 = new Matrix(); int nr, nc; //Distributions SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt; firstdistr; SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt; seconddistr; bool movable = false; bool resiable = false; // movable view port int contgleft = 0; int contgtop = 50; int contgwid = 300; int contgheight = 400; int mouseDeltax=0; int mouseDeltay=0; Rectangle viewPortcontig=new Rectangle(0,50, 300, 400); private void button1_Click(object sender, EventArgs e) { var filePath = string.Empty; openFileDialog1.InitialDirectory = \u0026#34;c:\\\\\u0026#34;; openFileDialog1.Filter = \u0026#34;csv files (*.csv)|*.csv|All files (*.*)|*.*\u0026#34;; openFileDialog1.FilterIndex = 2; openFileDialog1.RestoreDirectory = true; if (openFileDialog1.ShowDialog() == DialogResult.OK) { //Get the path of specified file filePath = openFileDialog1.FileName; //Read the contents of the file into a stream using (TextFieldParser csvParser = new TextFieldParser(filePath)) { csvParser.CommentTokens = new string[] { \u0026#34;#\u0026#34; }; csvParser.SetDelimiters(new string[] { \u0026#34;,\u0026#34; }); csvParser.HasFieldsEnclosedInQuotes = true; // Save the row with the column names string[] fieldsNames = csvParser.ReadFields(); attributename.AddRange(fieldsNames); int i = 0; while (!csvParser.EndOfData) { // Read current line fields, pointer moves to the next line. string[] fields = csvParser.ReadFields(); ElementoDisribuzione elem = new ElementoDisribuzione(fields[0]); int j = 0; foreach (String field in fields) { if (!String.IsNullOrEmpty(field)) { double tmp; if (Double.TryParse(field, out tmp)) { elem.setVariable(fieldsNames[j], new Tuple\u0026lt;Object, Type\u0026gt;(tmp, tmp.GetType())); medie.addAttribute(fieldsNames[j], tmp); } else elem.setVariable(fieldsNames[j], new Tuple\u0026lt;Object, Type\u0026gt;(field, field.GetType())); } j++; } csvContent.Add(i, elem); distr.addElementoDef(elem); i++; } } button2.Visible = true; } } private void button2_Click(object sender, EventArgs e) { ; foreach (var elem in attributename) contextMenuStrip1.Items.Add(elem); contextMenuStrip1.Visible = true; } private void contextMenuStrip1_Opening(object sender, CancelEventArgs e) { } private void contextMenuStrip1_ItemClicked(object sender, ToolStripItemClickedEventArgs e) { double media = 0; double stdVariation; List\u0026lt;Double\u0026gt; values=new List\u0026lt;double\u0026gt;(0); medie.getMedia(e.ClickedItem.Text, out media); //se la media è diversa da zero sono sicuro che è double if (media != 0) { Tuple\u0026lt;Object, Type\u0026gt; tmp; foreach (var elm in csvContent.Values) { elm.getVariable(e.ClickedItem.Text, out tmp); values.Add((double)tmp.Item1); } medie.getStandardDeviation(e.ClickedItem.Text, values,out stdVariation); distr.getdistribuzioneN(e.ClickedItem.Text, out firstdistr); } else stdVariation = 0; bivariante.Add(e.ClickedItem.Text); button2.Visible = false; foreach (var elem in attributename) contextMenuStrip2.Items.Add(elem); contextMenuStrip2.Visible = true; } private void contextMenuStrip2_ItemClicked(object sender, ToolStripItemClickedEventArgs e) { double media2 = 0; double stdVariation; List\u0026lt;Double\u0026gt; values = new List\u0026lt;double\u0026gt;(0); bool isDouble = false; medie.getMedia(e.ClickedItem.Text, out media2); if (media2 != 0) { isDouble = true; Tuple\u0026lt;Object, Type\u0026gt; tmp; foreach (var elm in csvContent.Values) { elm.getVariable(e.ClickedItem.Text, out tmp); values.Add((double)tmp.Item1); } medie.getStandardDeviation(e.ClickedItem.Text, values, out stdVariation); distr.getdistribuzioneN(e.ClickedItem.Text, out seconddistr); } else stdVariation = 0; bivariante.Add(e.ClickedItem.Text); bivariantMatrix = distr.getbivariantmatrix(bivariante, csvContent.Values, out nr, out nc); this.button3.Visible = true; } private void button3_Click(object sender, EventArgs e) { creaGrafici(g); } private void creaGrafici(Graphics g) { //viewport scatterport Rectangle viewPort = new Rectangle(300, 50, 400,400); int i = 0; // window double minX_Window = 0; double maxX_Window = 400; double minY_Window = 0; double maxY_Window = 400; g.Clear(Color.DarkGray); g.FillRectangle(Brushes.White , viewPort); g.DrawLine(new Pen(Color.Black,2), viewPort.X,viewPort.Y ,viewPort.X, (viewPort.Y +viewPort.Height)); g.DrawLine(new Pen(Color.Black,2), viewPort.X,(viewPort.Y + viewPort.Height),(viewPort.X+viewPort.Width), (viewPort.Y + viewPort.Height)); m.Translate(-(int)minX_Window,-(int)minY_Window,MatrixOrder.Append); m.Scale( (int)(viewPort.Width / (maxX_Window - minX_Window)),(int)(-viewPort.Height / (maxY_Window - minY_Window)), MatrixOrder.Append); m.Translate(viewPort.Left, viewPort.Top + viewPort.Height, MatrixOrder.Append); List\u0026lt;PointF\u0026gt; points = new List\u0026lt;PointF\u0026gt;(); foreach(var elem in csvContent) { Tuple\u0026lt;Object,Type \u0026gt;a, b; float x,y; elem.Value.getVariable(bivariante.ElementAt(0), out a); elem.Value.getVariable(bivariante.ElementAt(1), out b); x = (float)(double)a.Item1; y = (float)(double)b.Item1; points.Add(new PointF(x, y)); } PointF[] myPoints = points.ToArray(); PointF[] myPointsreal = points.ToArray(); i = 0; m.TransformPoints(myPoints ); foreach(PointF punto in myPoints) { if (myPointsreal[i].X \u0026lt;= maxX_Window \u0026amp;\u0026amp; myPointsreal[i].Y \u0026lt;= maxY_Window) { g.FillEllipse(Brushes.Black, new Rectangle(new Point((int)(punto.X - 2), (int)(punto.Y - 2)), new Size(4, 4))); g.DrawString(myPointsreal[i].ToString(), new Font(\u0026#34;Arial\u0026#34;, 10), Brushes.Black,(int)(punto.X), (int)(punto.Y)); g.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(punto.X - 2), (int)(viewPort.Y + viewPort.Height - 2)), new Size(4, 4))); g.FillEllipse(Brushes.Red, new Rectangle(new Point((int)(viewPort.X), (int)(int)(punto.Y - 2)), new Size(4, 4))); } i++; ; } //Column x chart viewport Rectangle viewPort2 = new Rectangle(300, 450, 400, 100); g.FillRectangle(Brushes.White, viewPort2); g.DrawLine(new Pen(Color.Black, 2), viewPort2.X, viewPort2.Y, viewPort2.X, (viewPort2.Y + viewPort2.Height)); g.DrawLine(new Pen(Color.Black, 2), viewPort2.X, (viewPort2.Y + viewPort2.Height), (viewPort2.X + viewPort2.Width), (viewPort2.Y + viewPort2.Height)); m2.Translate(-(int)minX_Window, -(int)minY_Window, MatrixOrder.Append); m2.Scale((int)(viewPort2.Width / (maxX_Window - minX_Window)), (int)(-viewPort2.Height / (maxY_Window - minY_Window)), MatrixOrder.Append); m2.Translate(viewPort2.Left, viewPort2.Top + viewPort2.Height, MatrixOrder.Append); List\u0026lt;PointF\u0026gt; distrF = new List\u0026lt;PointF\u0026gt;(); foreach(var point in firstdistr) { distrF.Add(new PointF((float)((point.Key.Item2 - point.Key.Item1)/2 +point.Key.Item1), point.Value)); } PointF[] myPoints2 = distrF.ToArray(); PointF[] myPoints2real = distrF.ToArray(); i = 0; m2.TransformPoints(myPoints2); foreach (PointF punto in myPoints2) { if (myPoints2real[i].X \u0026lt;= maxX_Window \u0026amp;\u0026amp; myPoints2real[i].Y \u0026lt;= maxY_Window) g.FillRectangle(Brushes.DarkCyan, new Rectangle((int)punto.X,viewPort2.Top,viewPort2.Width/30, (int)myPoints2real[i].Y/10)); i++; } //contingeny Rectangle viewPort3 = new Rectangle(200, 50, 100, 400); g.FillRectangle(Brushes.White, viewPort3); g.DrawLine(new Pen(Color.Black, 2), viewPort3.X, viewPort3.Y, viewPort3.X, (viewPort3.Y + viewPort3.Height)); g.DrawLine(new Pen(Color.Black, 2), viewPort3.X, (viewPort3.Y + viewPort3.Height), (viewPort3.X + viewPort3.Width), (viewPort3.Y + viewPort3.Height)); m3.Translate(-(int)minX_Window, -(int)minY_Window, MatrixOrder.Append); m3.Scale((int)(viewPort3.Width / (maxX_Window - minX_Window)), (int)(-viewPort3.Height / (maxY_Window - minY_Window)), MatrixOrder.Append); m3.Translate(viewPort3.Left, viewPort3.Top + viewPort3.Height, MatrixOrder.Append); List\u0026lt;PointF\u0026gt; distrS = new List\u0026lt;PointF\u0026gt;(); foreach (var point in seconddistr) { distrS.Add(new PointF(point.Value, (float)((point.Key.Item2 - point.Key.Item1) / 2 + point.Key.Item1))); } PointF[] myPoints3 = distrS.ToArray(); PointF[] myPoints3real = distrS.ToArray(); i = 0; m3.TransformPoints(myPoints3); foreach (PointF punto in myPoints3) { if (myPoints3real[i].X \u0026lt;= maxX_Window \u0026amp;\u0026amp; myPoints3real[i].Y \u0026lt;= maxY_Window) g.FillRectangle(Brushes.DarkCyan, new Rectangle(viewPort3.Left, (int)punto.Y, (int)punto.X/10, viewPort3.Height/30)); i++; } //contingency createconting(g2, 0, 50,300,400); pictureBox1.Image = b; } private void createconting(Graphics g2, int dinamicleft, int dinamictop,int contgw,int contgh) { viewPortcontig.X = dinamicleft; viewPortcontig.Y = dinamictop; viewPortcontig.Width = contgw; viewPortcontig.Height = contgh; //viewPortcontig.Location= new Point(viewPortcontig.Location.X+dinamicleft,viewPortcontig.Location.Y+dinamictop); g2.Clear(BackColor); g2.FillRectangle(Brushes.White, viewPortcontig); int j = 0; for (int i = 0; i \u0026lt;= nr; i++) { for (j = 0; j \u0026lt;= nc; j++) { Rectangle tmp = new Rectangle(viewPortcontig.Left + (j * (viewPortcontig.Width / (nc + 1))), viewPortcontig.Top + (i * (viewPortcontig.Height / (nr + 1))), viewPortcontig.Width / (nc + 1), viewPortcontig.Height / (nr + 1)); g2.DrawRectangle(new Pen(Color.Black, 2), tmp); g2.DrawString(bivariantMatrix[i, j], new Font(\u0026#34;Arial\u0026#34;, 6), Brushes.Black, tmp); } } pictureBox2.Image = contb ; } private void pictureBox2_MouseDown(object sender, MouseEventArgs e) { if ( (e.Location.Y\u0026gt;=viewPortcontig.Top \u0026amp;\u0026amp;e.Location.Y \u0026lt;= (viewPortcontig.Top+viewPortcontig.Height))\u0026amp;\u0026amp;(e.Location.X \u0026gt;= viewPortcontig.Left \u0026amp;\u0026amp; e.Location.X \u0026lt;= (viewPortcontig.Left + viewPortcontig.Width))) { if (e.Button == MouseButtons.Left) movable = true; if (e.Button == MouseButtons.Right) resiable = true; mouseDeltax = e.Location.X; mouseDeltay = e.Location.Y; } } private void pictureBox2_MouseLeave(object sender, EventArgs e) { resiable = false; movable = false; } private void pictureBox2_MouseMove(object sender, MouseEventArgs e) { if (movable == true) { contgleft = e.Location.X; contgtop = e.Location.Y; if (contgleft \u0026lt;= 0) contgleft = 0; if (contgtop \u0026lt;= 20) contgtop = 20; } if (resiable == true) { mouseDeltax = -mouseDeltax + e.Location.X ; mouseDeltay = -mouseDeltay + e.Location.Y; contgwid += mouseDeltax/40; contgheight += mouseDeltay/40; } createconting(g2, contgleft, contgtop,contgwid,contgheight); } private void pictureBox2_MouseUp(object sender, MouseEventArgs e) { resiable = false; movable = false; } private void pictureBox1_Click(object sender, EventArgs e) { } } } ","date":"2021-10-18T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/6_a/","title":"6_A"},{"content":"\n1_RA assignament Request Understand how the floating point representation works and describe systematically (possibly using categories) all the possible problems that can happen. Try to classify the various issues and limitations (representation, comparison, rounding, propagation, approximation, loss of significance, cancellation, etc.) and provide simple examples for each of the categories you have identified\nFloating point notation It\u0026rsquo;s a fantastic thing, we could express a vast range of value in a very efficent way: 32 bit notation: The frist bit is for sign, then 8 bit of exponent (frist bit is sign of the exponent ) so from 2^-127 to 2^127 and then 23 bit of mantissa.\nLimitation A floating-point format has limited range and precision. These limitations can be understood by considering using scientific notation with a limited range of exponents and a limited number of digits in the mantissa.\nRange limitation: A fixed number of \u0026ldquo;Exp\u0026rdquo; bits is comparable to limiting the size of the exponent in scientific notation.\nPrecision limitation: A fixed number of \u0026ldquo;Fraction\u0026rdquo; bits is comparable to limiting the number of digits in the mantissa in scientific notation. [1]\nErrors: Approximation this notation anyway present some problem,for example on how to rappreset 0.1, 0.2 ,0.3 without getting an error on the 17th decimal place that even if low is an approximation,and even if solution such as use decimal notation exist we should know this behaveiour.[2]\nErrors: Rounding Because floating-point numbers have a limited number of digits, they cannot represent all real numbers accurately: when there are more digits than the format allows, the leftover ones are omitted - the number is rounded. There are three reasons why this can be necessary: [2]\nToo many significant digits\nThe great advantage of floating point is that leading and trailing zeroes (within the range provided by the exponent) don’t need to be stored. But if, without those, there are still more digits than the significand can store, rounding becomes necessary. In other words, if your number simply requires more precision than the format can provide, you’ll have to sacrifice some of it, which is no big surprise. For example, with a floating point format that has 3 digits in the significand, 1000 does not require rounding, and neither does 10000 or 1110 - but 1001 will have to be rounded. With the large number of significand digits available in typical floating-point formats, this may seem to be a rarely encountered problem, but if you perform a sequence of calculations, especially multiplication and division, you can very quickly reach this point. Periodical digits\nAny (irreducible) fraction where the denominator has a prime factor that does not occur in the base requires an infinite number of digits that repeat periodically after a certain point, and this can already happen for very simple fractions. For example, in decimal 1/4, 3/5 and 8/20 are finite, because 2 and 5 are the prime factors of 10. But 1/3 is not finite, nor is 2/3 or 1/7 or 5/6, because 3 and 7 are not factors of 10. Fractions with a prime factor of 5 in the denominator can be finite in base 10, but not in base 2 - the biggest source of confusion for most novice users of floating-point numbers. Non-rational numbers\nNon-rational numbers cannot be represented as a regular fraction at all, and in positional notation (no matter what base) they require an infinite number of non-recurring digits. Comparison Due to rounding errors, most floating-point numbers end up being slightly imprecise. As long as this imprecision stays small, it can usually be ignored. However, it also means that numbers expected to be equal (e.g. when calculating the same result through different correct methods) often differ slightly, and a simple equality test fails. For example:[2]\nfloat a = 0.15 + 0.15 float b = 0.1 + 0.2 if(a == b) // can be false! if(a \u0026gt;= b) // can also be false! Propagation While the errors in single floating-point numbers are usualy very small, even simple calculations on them can contain pitfalls that increase the error in the result way beyond just having the individual errors “add up”.[2] this usualy come-up with addition or subtraction\nof number of differet magnitude es: if you add 1 to 100000000000 the value will not change even if you do this 10000000000000 times When numbers are very close to each other and are subtracted: the result’s less significant digits consist mostly of rounding errors the more calculatuion are done the more the error propagate\nBONUS: THE GENIUS MOVE IN QUAKE III [1]Title:\u0026ldquo;Floating-Point-Limtation\u0026rdquo; url:\u0026ldquo;https://www.d.umn.edu/~gshute/asm/floating-point.xhtml\"\n[2]Title:\u0026ldquo;0.00112\u0026rdquo; url:\u0026ldquo;https://floating-point-gui.de/basic/\"\n","date":"2021-10-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/1_ra/","title":"1_RA"},{"content":"\n2_A assignament Request Create - in both languages C# and VB.NET - a demonstrative program which computes the online arithmetic mean (if it\u0026rsquo;s a numeric variable) and your own algo to compute the distribution for a discrete variable and for a continuous variable (can use values simulated with RANDOM object).\nMy Solution Code in C#\nCode in VB.net\nCode in zip(mirror)\nClass Elemento Distribuzione in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class ElementoDisribuzione { private String name; private Dictionary\u0026lt;String,Double\u0026gt; variabili; public ElementoDisribuzione(String nome) { this.name = nome; this.variabili = new Dictionary\u0026lt;string, double\u0026gt;(); } public void setVariable(String name,double value) { this.variabili.Add(name, value); } public bool getVariable(String name,out double ret) { if (this.variabili.TryGetValue(name, out ret)) return true; else return false; } public Dictionary\u0026lt;String, Double\u0026gt; getVariabili() { return this.variabili; } } Class MediaCalOnline in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class MediaCalOnline { Dictionary\u0026lt;String, double\u0026gt; medieAritmetica; Dictionary\u0026lt;String, int\u0026gt; numeroElementi; public MediaCalOnline() { medieAritmetica = new Dictionary\u0026lt;string, double\u0026gt;(); numeroElementi = new Dictionary\u0026lt;String, int\u0026gt;(); } public void addAttribute(String nome, double value) { double tmp; int i; if (medieAritmetica.ContainsKey(nome)) { medieAritmetica.TryGetValue(nome, out tmp); numeroElementi.TryGetValue(nome, out i); i++; tmp = tmp + (value - tmp) / i; numeroElementi.Remove(nome); medieAritmetica.Remove(nome); medieAritmetica.Add(nome, tmp); numeroElementi.Add(nome, i); } else { medieAritmetica.Add(nome, value); numeroElementi.Add(nome, 1); } } public bool getMedia(String name,out double i) { if (medieAritmetica.TryGetValue(name, out i)) return true; else return false; } public void addElemento(ElementoDisribuzione e) { foreach (var item in e.getVariabili()) addAttribute(item.Key, item.Value); } } Class Distribuzione in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Distribuzione { private Dictionary\u0026lt;String, SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt;\u0026gt; distr; double intervall = 10; public Distribuzione() { distr = new Dictionary\u0026lt;String, SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt;\u0026gt;(); } //intervall standard 10 public void addAttributDef(String s, double i) { addAttribute(s, i, intervall); } public void addAttribute(String s, double value, double inte) { SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt; actualdistr; double min, max; int i = 1; min = value - (value % inte); max = value + (inte - (value % inte)); Tuple\u0026lt;double, double\u0026gt; tmp = new Tuple\u0026lt;double, double\u0026gt;(min, max); if (!distr.TryGetValue(s, out actualdistr)) { actualdistr = new SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt;(); actualdistr.Add(tmp, 1); distr.Add(s, actualdistr); } else { if (!actualdistr.TryGetValue(tmp, out i)) actualdistr.Add(tmp, 1); else { i++; actualdistr.Remove(tmp); actualdistr.Add(tmp, i); } distr.Remove(s); distr.Add(s, actualdistr); } } public void addElemento(ElementoDisribuzione e, double inter) { foreach (var item in e.getVariabili()) { this.addAttribute(item.Key, item.Value, inter); } } public void addElementoDef(ElementoDisribuzione e) { addElemento(e, intervall); } public bool getdistribuzione(string s, out SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt; req) { if (distr.TryGetValue(s, out req)) return true; else return false; } } Main Form in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 public partial class Form1 : Form { public Form1() { InitializeComponent(); } Random r = new Random(); MediaCalOnline mc=new MediaCalOnline(); Distribuzione dc = new Distribuzione(); private void Form1_Load(object sender, EventArgs e) { } private void button1_Click(object sender, EventArgs e) { timer1.Interval = 2; timer1.Start(); button3.Visible = true; button2.Visible = true; button1.Visible = false; } private void button2_Click(object sender, EventArgs e) { timer2.Interval = 10; timer2.Start(); button2.Visible = false; } private void timer1_Tick(object sender, EventArgs e) { double height; ElementoDisribuzione studente = new ElementoDisribuzione(\u0026#34;Student\u0026#34;); height =r.NextDouble()+r.Next(140,200); studente.setVariable(\u0026#34;height\u0026#34;, height); mc.addElemento(studente); dc.addElementoDef(studente); richTextBox1.Text += \u0026#34;nuovo Studente altezza: \u0026#34; + height + Environment.NewLine; } private void timer2_Tick(object sender, EventArgs e) { double i; SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt; distTest =new SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt;(); mc.getMedia(\u0026#34;height\u0026#34;, out i); if (dc.getdistribuzione(\u0026#34;height\u0026#34;, out distTest)) { richTextBox3.Text = \u0026#34;\u0026#34;; foreach (var item in distTest) { richTextBox3.Text += item.Key.Item1 + \u0026#34;-\u0026#34; + item.Key.Item2 + \u0026#34; presenta \u0026#34; + item.Value + \u0026#34; entita \u0026#34;+Environment.NewLine; } } richTextBox2.Text = \u0026#34;the A M of the height is\u0026#34; + i + Environment.NewLine; } private void button3_Click(object sender, EventArgs e) { timer1.Stop(); timer2.Stop(); button1.Visible = true; button2.Visible = true; } } ","date":"2021-10-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/2_a/","title":"2_A"},{"content":"\n2_R assignament Request Describe the most common configuration of data repositories in the real world and corporate environment. Concepts such as Operational or Transactional systems (OLTP), Data Warehouse DW, Data Marts, Analytical and statistical systems (OLAP), etc. Try to draw a conceptual picture of how all these components may work together and how the flow of data and information is processed to extract useful knowledge from raw data.\nOnline transaction processing OLTP or Online Transaction Processing is a type of data processing that consists of executing a number of transactions occurring concurrently—online banking, shopping, order entry, or sending text messages, for example. These transactions traditionally are referred to as economic or financial transactions, recorded and secured so that an enterprise can access the information anytime for accounting or reporting purposes. [1]\nOnline analytical processing OLTP enables the real-time execution of large numbers of transactions by large numbers of people, whereas online analytical processing (OLAP) usually involves querying these transactions (also referred to as records) in a database for analytical purposes. OLAP helps companies extract insights from their transaction data so they can use it for making more informed decisions.[1]\nData Warehouse A data warehouse is a central repository of information that can be analyzed to make more informed decisions. Data flows into a data warehouse from transactional systems, relational databases, and other sources, typically on a regular cadence.[2]\nData mart A data mart is a structure / access pattern specific to data warehouse environments, used to retrieve client-facing data. The data mart is a subset of the data warehouse and is usually oriented to a specific business line or team. Whereas data warehouses have an enterprise-wide depth, the information in data marts pertains to a single department.[3]\nConceptual Picture Data flows from different Data sources(OLTP, OLAP, files, etc ) in a staging area, then re-analyzed and organized in a DW (usual data are anonymized and aggregated to get used for statistical purposes (As described in the GDPR)), then data are aggregated in a meaningful way in various datasets and at this point is available for analysis\n[1]\u0026ldquo;ORACLE\u0026rdquo;, \u0026ldquo;url\u0026rdquo;: \u0026ldquo;https://www.oracle.com/database/what-is-oltp/\"\n[2]\u0026ldquo;Amazon AWS\u0026rdquo;, \u0026ldquo;url\u0026rdquo;: \u0026ldquo;https://aws.amazon.com/it/data-warehouse/\"\n[3]\u0026ldquo;Data mart\u0026rdquo;, \u0026ldquo;url\u0026rdquo;: \u0026ldquo;https://en.wikipedia.org/wiki/Data_mart\"\n","date":"2021-10-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/2_r/","title":"2_R"},{"content":"\n2_RA assignament Request Do a review about charts useful for statistics and data presentation. What is the chart type that impressed you most and why ?\nScatterplot Very usefull when you want to show relationship between two continus variables: make correlation between variabliles easy visible.[1]\nLine Plot or Line Chart The line chart provides a meaningful comparison between two or more than two series,is also very useful in visualzing time series data or data changes over time,is the classical chart for market data: Column Chart or Vertical Bar Chart This is by far the most common chart, useful when comparing categorical or ordinal data, for illustrate distribution and for showing proportions or percentages of a whole.\nHorizontal Bar Chart Same as before but flipped, very easy to read useful for presentation Area Chart [2]Area chart combines Pie chart and Line chart features, and is one of the graph that provide most info, it\u0026rsquo;s possible to combine more series to make comparison:\nBubble Chart Make possible to display 3-dimensional data in 2 dimension infact the size of the bubble defines the value of the third dimension\nPie Chart Very useful when we need to understand the relative proportion of each value in a data distribution,anyway data could be difficult to understand[1]\nWaffle Chart or Square Pie Chart Usefull to get an high level view of contribution to a whole, used also for example by git hub to show per day contributions Spider Charts (Personal Favorite ) To visually compare three or more quantitative variables,the best option is to use a radar chart, also known as a spider or star chart. The chart usually consists of a series of radii, each representing a different category, that splay out from a center point like spokes.[2] The length of each “spoke” is proportionate to the value being compared. For each category, the spokes are then connected with a line of a designated pattern or color, forming a star-like shape with points equal to the number of categories. Why i choose this ? This chart can do comparison between various attribute at the same time and remain easy to understand and eye-catching, is very used and usefull for exemple in benchmarking and performance analysis [1] url:\u0026ldquo;https://medium.com/analytics-vidhya/top-10-most-useful-charts-in-data-visualization-a4c9365d03e4\" [2] url:\u0026ldquo;https://visme.co/blog/types-of-graphs/\"\n","date":"2021-10-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/2_ra/","title":"2_RA"},{"content":"\n3_A assignament Request Create an object providing a rectangular area which can be moved and resized using the mouse. This area will hold our future charts and graphics.\nMy Solution Code in C#\nMain Form: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { } private void panel1_Paint(object sender, PaintEventArgs e) { } bool allowResize = false; bool allowMove = false; private void resizaileBox_MouseUp(object sender, MouseEventArgs e) { allowResize = false; allowMove = false; } private void resizaileBox_MouseMove(object sender, MouseEventArgs e) { if (allowResize) { this.panel1.Height = resizaileBox.Top + e.Y; this.panel1.Width = resizaileBox.Left + e.X; } if (allowMove) { this.panel1.Location = new Point(this.panel1.Location.X + e.X, this.panel1.Location.Y + e.Y); } } private void resizaileBox_Click(object sender, EventArgs e) { } private void resizaileBox_MouseDown(object sender, MouseEventArgs e) { if (e.Button == MouseButtons.Right) allowResize = true; else allowMove = true; } } ","date":"2021-10-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/3_a/","title":"3_A"},{"content":"\n3_R assignament Request Show how we can obtain an online algo for the arithmetic mean and explain the various possible reasons why it is preferable to the \u0026ldquo;naive\u0026rdquo; algo based on the definition.\nArithmetic mean standard: The aritmetic Mean or simply the average is the sum of a collection of numbers divided by the count of numbers in the collection [1].\nThe formuala that we usually use for the calculation is this: Limitation If we are computing the arithmetic mean of dataset variables(statistic attribute), moreover if we do this in an interactive way(online) or for any kind of computational circumstance that involves this calculus, the classical formula doesn\u0026rsquo;t work very well since we have to fully keep all the value and then do the operation, this could bring to some error such as (but not limited to) segmentation fault, invalid pointer or stack overflow.\nIntercative way For remove the formula limitiation try to elaborate it in a different way: if we have only one element a1 the a.m \u0026ldquo;A\u0026rdquo; is = a1 this is our basic step. then let\u0026rsquo;s try to compute the algorithm for n value : So now we have an algo that is perfect for us, we can calculate the mean at each step and update it when other data is present; using this formula we resolve the issue of keep in memory a lot of values and perform arithmetic that could goes outside the bounds of the used variables\n[1] Jacobs, Harold R. (1994). Mathematics: A Human Endeavor (Third ed.). W. H. Freeman.\n","date":"2021-10-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/3_r/","title":"3_R"},{"content":"\n3_RA assignament Request Do a comprehensive research about the GRAPHICS object and all its members (to get ready to create any statistical chart.)\nHow we have used Graphics Usualy in our project we use the graphics class associated with a Bitmap(attached to an image box ) ,the Graphics class infact provides methods for drawing objects to the display device,also remember that Graphics is associated with a specific device context.[1]It\u0026rsquo;s basic mean is to draw object in the graphical context were is assigned\nDraw We can draw many different shapes and lines by using a Graphics object anc calling his methods(these methods include DrawLine, DrawArc, DrawClosedCurve, DrawPolygon,DrawElipse and DrawRectangle),we can for sure starting from this create more complex method to draw for example meaningfull charts or 3d graphics,or 2D graphics, in fact we could also see the graphics class as our API to .NET Graphical engine. Text writing For sure we can also arrange text on the screen using graphics,selecting his size font and brushes using the DrowsString method es: DrawString(\u0026ldquo;yourText\u0026rdquo;, new Font(\u0026ldquo;Tahoma\u0026rdquo;,8), Brushes.Black, rectf); [1]\u0026ldquo;url\u0026rdquo;:\u0026ldquo;https://docs.microsoft.com/en-us/dotnet/api/system.drawing.graphics?view=windowsdesktop-5.0#methods\"\n","date":"2021-10-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/3_ra/","title":"3_RA"},{"content":"\n4_A assignament Request Create a program - in both languages C# and VB.NET (and optionally in js) - to read data from a CSV file, and store it into a suitable collection of suitably designed objects, for further processing. Compute mean and standard deviation and frequency distribution for at least one of the variable, and for one pair of variables.\nMy Solution Code in C#\nCode in VB.net\nClass Elemento Distribuzione in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class ElementoDisribuzione { private String name; private Dictionary\u0026lt;String, Tuple\u0026lt;Object,Type\u0026gt;\u0026gt; variabili; public ElementoDisribuzione(String nome) { this.name = nome; this.variabili = new Dictionary\u0026lt;string, Tuple\u0026lt;Object, Type\u0026gt;\u0026gt;(); } public void setVariable(String name, Tuple\u0026lt;Object, Type\u0026gt;s) { this.variabili.Add(name,s); } public bool getVariable(String name, out Tuple\u0026lt;Object, Type\u0026gt; ret) { if (this.variabili.TryGetValue(name, out ret)) return true; else return false; } public Dictionary\u0026lt;String, Tuple\u0026lt;Object, Type\u0026gt;\u0026gt; getVariabili() { return this.variabili; } } Class MediaCalOnline in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class MediaCalOnline { Dictionary\u0026lt;String, double\u0026gt; medieAritmetica; Dictionary\u0026lt;String, int\u0026gt; numeroElementi; public MediaCalOnline() { medieAritmetica = new Dictionary\u0026lt;string, double\u0026gt;(); numeroElementi = new Dictionary\u0026lt;String, int\u0026gt;(); } public void addAttribute(String nome, double value) { double tmp; int i; if (medieAritmetica.ContainsKey(nome)) { medieAritmetica.TryGetValue(nome, out tmp); numeroElementi.TryGetValue(nome, out i); i++; tmp = tmp + (value - tmp) / i; numeroElementi.Remove(nome); medieAritmetica.Remove(nome); medieAritmetica.Add(nome, tmp); numeroElementi.Add(nome, i); } else { medieAritmetica.Add(nome, value); numeroElementi.Add(nome, 1); } } public bool getMedia(String name,out double i) { if (medieAritmetica.TryGetValue(name, out i)) return true; else return false; } public void addElemento(ElementoDisribuzione e) { foreach (var item in e.getVariabili()) if (item.Value.Item2 == typeof(Double)) addAttribute(item.Key,(double) item.Value.Item1); } public bool getStandardDeviation(String name, List\u0026lt;Double\u0026gt; list, out double i) { double media; i = 0; if (!medieAritmetica.TryGetValue(name, out media)) return false; foreach (double elemnt in list) { i = i + ((elemnt - media) * (elemnt - media)); } i = i / list.Count; i = Math.Sqrt(i); return true; } } Class Distribuzione in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 class Distribuzione { private Dictionary\u0026lt;String, SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt;\u0026gt; distrN; private Dictionary\u0026lt;string, SortedDictionary\u0026lt;String, int\u0026gt;\u0026gt; distrS; double intervall = 10; public Distribuzione() { distrN = new Dictionary\u0026lt;String, SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt;\u0026gt;(); distrS = new Dictionary\u0026lt;String, SortedDictionary\u0026lt;String, int\u0026gt;\u0026gt;(); } //intervall standard 10 public void addAttributNDef(String s, double i) { addAttributeN(s, i, intervall); } public void addAttributeN(String s, double value, double inte) { SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt; actualdistr; double min, max; int i = 1; min = value - (value % inte); max = value + (inte - (value % inte)); Tuple\u0026lt;double, double\u0026gt; tmp = new Tuple\u0026lt;double, double\u0026gt;(min, max); if (!distrN.TryGetValue(s, out actualdistr)) { actualdistr = new SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt;(); actualdistr.Add(tmp, 1); distrN.Add(s, actualdistr); } else { if (!actualdistr.TryGetValue(tmp, out i)) actualdistr.Add(tmp, 1); else { i++; actualdistr.Remove(tmp); actualdistr.Add(tmp, i); } distrN.Remove(s); distrN.Add(s, actualdistr); } } private void addAttributeS(string key, String value) { SortedDictionary\u0026lt;String, int\u0026gt; actualdistrS; int i=1; if (!distrS.TryGetValue(key, out actualdistrS)) { actualdistrS = new SortedDictionary\u0026lt;String, int\u0026gt;(); actualdistrS.Add(value, 1); distrS.Add(key, actualdistrS); } else { if (!actualdistrS.TryGetValue(value, out i)) actualdistrS.Add(value, 1); else { i++; actualdistrS.Remove(value); actualdistrS.Add(value, i); } distrS.Remove(key); distrS.Add(key, actualdistrS); } } public void addElemento(ElementoDisribuzione e, double inter) { foreach (var item in e.getVariabili()) { if (item.Value.Item2 == typeof(string)) this.addAttributeS(item.Key, (String)item.Value.Item1); else this.addAttributeN(item.Key, (double)item.Value.Item1, inter); } } public void addElementoDef(ElementoDisribuzione e) { addElemento(e, intervall); } public bool getdistribuzioneN(string s, out SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt; req) { if (distrN.TryGetValue(s, out req)) return true; else return false; } public bool getdistribuzioneS(string s, out SortedDictionary\u0026lt;String, int\u0026gt; req) { if (distrS.TryGetValue(s, out req)) return true; else return false; } public string[,] getbivariantmatrix(List\u0026lt;string\u0026gt; bivariante, Dictionary\u0026lt;int, ElementoDisribuzione\u0026gt;.ValueCollection values, out int numeroRighe, out int numeroColonnne) { string[] variabili = bivariante.ToArray(); SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt; columns; SortedDictionary\u0026lt;Tuple\u0026lt;Double, double\u0026gt;, int\u0026gt; rows; int i, j = 0; distrN.TryGetValue(variabili[0], out columns); distrN.TryGetValue(variabili[1], out rows); //mi ricavo gli intervalli double intervalloRow = 0; while (intervalloRow == 0) { intervalloRow = rows.ElementAt(j).Key.Item2 - rows.ElementAt(j).Key.Item1; j++; } j = 0; double intervalloCol = 0; while (intervalloCol == 0) {intervalloCol = columns.ElementAt(j).Key.Item2 - columns.ElementAt(j).Key.Item1; j++; } numeroColonnne = columns.Count(); numeroRighe = rows.Count(); String[,] outputM = new String[numeroRighe+1,numeroColonnne+1]; int[,] outputMV = new int[numeroRighe, numeroColonnne]; //inizilizo la matrice outputMatriceValori for (i = 0; i \u0026lt; numeroRighe; i++) for (j = 0; j \u0026lt; numeroColonnne; j++) outputMV[i,j] = 0; i = 1; j = 1; outputM[0, 0] = \u0026#34; \u0026#34;; // riempo gli estremi della tabella foreach(var column in columns.Keys) { outputM[0, i] = column.ToString(); i++; } foreach (var row in rows.Keys) { outputM[j, 0] = row.ToString(); j++; } //cerco l\u0026#39;intervallo giusto per entrambi e li carico foreach (var elm in values) { bool trov0 = false; bool trov1 = false; Tuple\u0026lt;Object, Type\u0026gt; tmpv0; Tuple\u0026lt;Object, Type\u0026gt; tmpv1; elm.getVariable(variabili[0], out tmpv0); elm.getVariable(variabili[1], out tmpv1); i = 0; j = 0 ; while (!trov0\u0026amp;\u0026amp; i\u0026lt;numeroColonnne) { if (((double)tmpv0.Item1 - columns.Keys.ElementAt(i).Item1) \u0026lt;= intervalloCol) trov0 = true; else i++; } while (!trov1\u0026amp;\u0026amp;j\u0026lt;numeroRighe) { if ((double)tmpv1.Item1 - rows.Keys.ElementAt(j).Item1 \u0026lt;= intervalloCol) trov1 = true; else j++; } if(trov0 \u0026amp;\u0026amp; trov1)outputMV[j, i] += 1; } for (i = 1; i \u0026lt;= numeroColonnne; i++) for (j = 1; j \u0026lt;= numeroRighe; j++) outputM[j, i] = outputMV[j - 1, i - 1].ToString(); return outputM; } } } Main Form in C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 public partial class Form1 : Form { public Form1() { InitializeComponent(); } Dictionary\u0026lt;int, ElementoDisribuzione\u0026gt; csvContent = new Dictionary\u0026lt;int, ElementoDisribuzione\u0026gt;(); Distribuzione distr = new Distribuzione(); MediaCalOnline medie = new MediaCalOnline(); List\u0026lt;String\u0026gt; attributename = new List\u0026lt;string\u0026gt;(); List\u0026lt;String\u0026gt; bivariante = new List\u0026lt;string\u0026gt;();//per ora poi diventera n variante; private void button1_Click(object sender, EventArgs e) { var filePath = string.Empty; openFileDialog1.InitialDirectory = \u0026#34;c:\\\\\u0026#34;; openFileDialog1.Filter = \u0026#34;csv files (*.csv)|*.csv|All files (*.*)|*.*\u0026#34;; openFileDialog1.FilterIndex = 2; openFileDialog1.RestoreDirectory = true; if (openFileDialog1.ShowDialog() == DialogResult.OK) { //Get the path of specified file filePath = openFileDialog1.FileName; //Read the contents of the file into a stream using (TextFieldParser csvParser = new TextFieldParser(filePath)) { csvParser.CommentTokens = new string[] { \u0026#34;#\u0026#34; }; csvParser.SetDelimiters(new string[] { \u0026#34;,\u0026#34; }); csvParser.HasFieldsEnclosedInQuotes = true; // Save the row with the column names string[] fieldsNames = csvParser.ReadFields(); attributename.AddRange(fieldsNames); int i = 0; while (!csvParser.EndOfData) { // Read current line fields, pointer moves to the next line. string[] fields = csvParser.ReadFields(); ElementoDisribuzione elem = new ElementoDisribuzione(fields[0]); int j = 0; foreach (String field in fields) { if (!String.IsNullOrEmpty(field)) { double tmp; if (Double.TryParse(field, out tmp)) { elem.setVariable(fieldsNames[j], new Tuple\u0026lt;Object, Type\u0026gt;(tmp, tmp.GetType())); medie.addAttribute(fieldsNames[j], tmp); } else elem.setVariable(fieldsNames[j], new Tuple\u0026lt;Object, Type\u0026gt;(field, field.GetType())); } j++; } csvContent.Add(i, elem); distr.addElementoDef(elem); i++; } } button2.Visible = true; } } private void button2_Click(object sender, EventArgs e) { ; foreach (var elem in attributename) contextMenuStrip1.Items.Add(elem); contextMenuStrip1.Visible = true; } private void contextMenuStrip1_Opening(object sender, CancelEventArgs e) { } private void contextMenuStrip1_ItemClicked(object sender, ToolStripItemClickedEventArgs e) { richTextBox1.Text += \u0026#34;-------------------------------------------------------------\u0026#34; + Environment.NewLine; richTextBox1.Text += e.ClickedItem.Text + Environment.NewLine; double media = 0; double stdVariation; List\u0026lt;Double\u0026gt; values=new List\u0026lt;double\u0026gt;(0); SortedDictionary\u0026lt;Tuple\u0026lt;double, double\u0026gt;, int\u0026gt; firstdistr; medie.getMedia(e.ClickedItem.Text, out media); //se la media è diversa da zero sono sicuro che è double if (media != 0) { Tuple\u0026lt;Object, Type\u0026gt; tmp; foreach (var elm in csvContent.Values) { elm.getVariable(e.ClickedItem.Text, out tmp); values.Add((double)tmp.Item1); } medie.getStandardDeviation(e.ClickedItem.Text, values,out stdVariation); distr.getdistribuzioneN(e.ClickedItem.Text, out firstdistr); foreach (var el in firstdistr) { richTextBox1.Text += el.Key.ToString() + \u0026#34; : \u0026#34; + el.Value + Environment.NewLine; } } else stdVariation = 0; richTextBox1.Text += e.ClickedItem + \u0026#34; with average: \u0026#34; + media + \u0026#34; and standard variation: \u0026#34; + stdVariation+ Environment.NewLine; bivariante.Add(e.ClickedItem.Text); button2.Visible = false; foreach (var elem in attributename) contextMenuStrip2.Items.Add(elem); contextMenuStrip2.Visible = true; } private void contextMenuStrip2_ItemClicked(object sender, ToolStripItemClickedEventArgs e) { richTextBox1.Text += \u0026#34;-------------------------------------------------------------\u0026#34; + Environment.NewLine; richTextBox1.Text += e.ClickedItem.Text + Environment.NewLine; double media2 = 0; double stdVariation; List\u0026lt;Double\u0026gt; values = new List\u0026lt;double\u0026gt;(0); SortedDictionary\u0026lt;Tuple\u0026lt;double,double\u0026gt;,int\u0026gt; seconddistr; bool isDouble = false; medie.getMedia(e.ClickedItem.Text, out media2); if (media2 != 0) { isDouble = true; Tuple\u0026lt;Object, Type\u0026gt; tmp; foreach (var elm in csvContent.Values) { elm.getVariable(e.ClickedItem.Text, out tmp); values.Add((double)tmp.Item1); } medie.getStandardDeviation(e.ClickedItem.Text, values, out stdVariation); distr.getdistribuzioneN(e.ClickedItem.Text, out seconddistr); foreach (var el in seconddistr) { richTextBox1.Text += el.Key.ToString() +\u0026#34; : \u0026#34; + el.Value +Environment.NewLine; } } else stdVariation = 0; richTextBox1.Text += e.ClickedItem + \u0026#34; with average: \u0026#34; + media2 + \u0026#34; and standard variation: \u0026#34; + stdVariation + Environment.NewLine; bivariante.Add(e.ClickedItem.Text); richTextBox1.Text += Environment.NewLine; int nr, nc; String[,] bivariantMatrix = distr.getbivariantmatrix(bivariante, csvContent.Values, out nr, out nc); for (int i = 0; i \u0026lt;= nr; i++) { richTextBox1.Text += Environment.NewLine; for (int j = 0; j \u0026lt;= nc; j++) { richTextBox1.Text += bivariantMatrix[i, j].PadLeft(6); } } } } ","date":"2021-10-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/4_a/","title":"4_A"},{"content":"\n4_R assignament Request Explain what are marginal, joint and conditional distributions and how we can explain the Bayes theorem using relative frequencies. Explain the concept of statistical independence and why, in case of independence, the relative joint frequencies are equal to the products of the corresponding marginal frequencies. Margianal Are the distributions that we find on the margin of the bivariate distribution matrix, describes the frequenceis in wich one variabiles has a certain value without restriction on the value of the other\nConditional ditribution Are the distribution that we find on a row or on a column of the bivariate distribution matrix, describes the frequenceis in which one variabiles has a certain value taken the other fixed\nJoint distribution Describes the frequency in which a particular values for both the variable appear.\nBayes theorem and realtive frequencies Bayes theorem talk about probability but relative frequency are nothing more than \u0026ldquo;experimental\u0026rdquo; probability so we can use it to better understand the theorem and explain it, in fact from the matrix we can calculate all the conditional probability,for example:\nwe have two dice x,y one with 6 face x and the other with 8 we do a lot of random tentative what are the probabilty of 3 on x given y=6 X/Y 1 2 3 4 5 6 7 8 1 100 100 100 100 100 100 100 100 2 100 100 100 100 100 100 100 100 3 100 100 100 100 100 100 100 100 4 100 100 100 100 100 100 100 100 5 100 100 100 100 100 100 100 100 6 100 100 100 100 100 100 100 100 For finding this (p(A\\B)= p(x=3\\y=6)) we look at the table and see that there is 100 in the column x=3, row y=6 point so the probababilty of this event will be of 100/ on something and in this case something is all the throwing when y=6 that are 600. So the probabyity is 1/6,but what about the inverse case? lets\u0026rsquo; invert the case 1.we are on the same point as before but whe need to divide for the total case when x=3 insted as what we have done before.\nSo 100/800=1/8; now let\u0026rsquo;s consider P(X=3)= 1/(all the possible value of x )=1/6 and so P(y=6) is 1/8\nwe have that the frist result P(x=3/y=6)=1/6 and the second result that is 1/8 we can easy spot that: 1/6=(1/8 * 1/6)/1/1/8 bring it to the formula P(x=3\\y=6)=(P(y=6/x=3)*P(x=3))/P(y=6) and in general the Bayes theorem: P(A\\B)=(P(B/A)*P(A))/P(B) Statistical independence We have statistical independence between two variables when there is no correleation between the variables and so the probability(frequency) that an avent occur given another is the same as the probability that that event occur. in the bivariant matrix this mean that we have the same distrbution of frequency, in evry row and in the margin,or in evry column and the margin, and so we could say that the relative joint frequencies are equal to the products of the corresponding marginal frequencies.\n[1]\u0026ldquo;url\u0026rdquo;:\u0026quot;Teorema_di_Bayes\u0026quot;\n","date":"2021-10-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/4_r/","title":"4_R"},{"content":"\n5_A assignament Request Compute - in both languages C# and VB.NET (and optionally in js) - a frequency distribution of the meaningful words from any text file and create a personal graphical representation of the corresponding \u0026ldquo;word cloud\u0026rdquo; (in case, can use animation if you wish), keeping into account the frequencies of the words.\nMy Solution Code in C and VB.NET#\nMain Form: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public partial class Form1 : Form { public Form1() { InitializeComponent(); } SortedDictionary\u0026lt;String, int\u0026gt; wDstr = new SortedDictionary\u0026lt;string, int\u0026gt;(); private void Form1_Load(object sender, EventArgs e) { } private void button1_Click(object sender, EventArgs e) { var filePath = string.Empty; openFileDialog1.InitialDirectory = \u0026#34;c:\\\\\u0026#34;; openFileDialog1.Filter = \u0026#34;txt files (*.txt)|*.txt|All files (*.*)|*.*\u0026#34;; openFileDialog1.FilterIndex = 2; openFileDialog1.RestoreDirectory = true; openFileDialog1.Title = \u0026#34;Select Text File\u0026#34;; if (openFileDialog1.ShowDialog() == DialogResult.OK) { //Get the path of specified file filePath = openFileDialog1.FileName; //Read the contents of the file into a stream using (StreamReader sr = new StreamReader(filePath)) { while (sr.Peek() \u0026gt;= 0) { string line = sr.ReadLine(); char[] delimiters = new char[] { \u0026#39; \u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39; }; string[] words = line.Split(delimiters, StringSplitOptions.RemoveEmptyEntries); int i = 0; foreach (string word in words) { if (!wDstr.TryGetValue(word, out i)) wDstr.Add(word, 1); else { wDstr.Remove(word); i++; wDstr.Add(word, i); } } } } int j = 0; foreach(var w in wDstr) { chart1.Series[\u0026#34;Words\u0026#34;].Points.AddXY(w.Key, w.Value); } } } } ","date":"2021-10-05T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/5_a/","title":"5_A"},{"content":"\nStatistics: “The science of kings, political and science of statecraft.”[1] Statistics is the discipline that concerns the collection, organization, analysis, interpretation, and presentation of data.[2]\nStatistics Application domain Statistics is a very old subject in fact, early writings on statistical inference can be found in the VII century,[2] but its reach out continue to evolve even today nevertheless is an essential tool to deal with any sort of data, make reports and provide governance tools.\nIs a branch of mathematic? Statistics use mathematics to interact and manipulate data, when we are dealing with the application of probability theory inside the statistic we are defacto talking about mathematical statistics, people tend to identify this with statistics itself saying that statistics is a branch of mathematics, but this is no more true as saying that engineering is a branch of mathematic [3]\n[4] \u0026ldquo;Mathematics is a branch of science that involves studying logic and structure on an abstract level.It should also be noted that while only certain parts of mathematics are considered \u0026ldquo;pure\u0026rdquo;, mathematics is more than just applied statistics in the sense that all areas of study are connected by a set of common foundations and ideas.\u0026rdquo; [4]\u0026ldquo;Statistics is a discipline that applies the principles of mathematics to scientific data. It focuses on methods for summarizing and communicating the results of surveys, experiments, or observations. Statistics help inform us about everything from what popular movies are out, how many people were convicted of crimes last year, whether global warming is occurring, etc. Unlike pure mathematics, statistics deals with attempting to make statements about reality using empirical evidence.\u0026rdquo;\nCould be consider a science? Science is the mapping of nature into a form that humans can understand,so every discipline or art fallling into this definition is considerble as a science. However the interpretation of statistics is usualy colser to an art, a technology,or as a tool[5] but since statistics enables a researcher to draw meaningful conclusions from masses of data[6] and uses the scientific method to drow conclusion for sure it can be recognized as a science.\nThe scientic method: review of facts, theories, and proposals, Formulation of a logical hypothesis that can be evaluated by experimental methods Objective evaluation of the hypothesis on the basis of experimental results. Is application in Statistics Its application lies in many aspects of the design of the experiment but generaly include:\nInitial planning of the experiment, Collection of data, Analysis of results, Summarizing of the data, and Evaluation of the uncertainty of any statistical inference drawn from the results. [6] Fun Facts Statistics is probabably at the base of Psychohistory\nBibliography [1]\u0026ldquo;EMATHZONE\u0026rdquo;, \u0026ldquo;url\u0026rdquo;: \u0026ldquo;https://www.emathzone.com/tutorials/basic-statistics/definition-of-statistics.html\"\n[2]\u0026ldquo;Wiki-Statistica\u0026rdquo;,\u0026ldquo;url\u0026rdquo;: \u0026ldquo;https://it.wikipedia.org/wiki/Statistica\"\n[3]\u0026ldquo;Quora:Is-statistics-a-branch-of-mathematics-or-a-discipline-of-its-own\u0026rdquo;,\u0026ldquo;url\u0026rdquo;: \u0026ldquo;https://www.quora.com/Is-statistics-a-branch-of-mathematics-or-a-discipline-of-its-own\"\n[4]\u0026ldquo;Quora: the-difference-between-mathematics-and-statistics\u0026rdquo;\u0026rdquo;,\u0026ldquo;url\u0026rdquo;: \u0026ldquo;https://www.quora.com/What-is-the-difference-between-mathematics-and-statistics\"\n[5]\u0026rdquo; Journal of the Royal Statistical Society\u0026rdquo;,\u0026ldquo;url\u0026rdquo;:\u0026ldquo;https://www.jstor.org/stable/2344809\"\n[5]\u0026ldquo;ndsu:statistics review \u0026ldquo;,\u0026ldquo;url\u0026rdquo;:\u0026ldquo;https://www.ndsu.edu/faculty/horsley/Stat_rev.pdf\"\n[7]\u0026ldquo;Foundation\u0026rdquo;,\u0026ldquo;url\u0026rdquo;:\u0026ldquo;https://asimov.fandom.com/wiki/Psychohistory\"\n","date":"2021-09-29T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/1_r/","title":"1_R"},{"content":"1_A assignament Request Create - in both languages C# and VB.NET - a program which does the following simple tasks to get acquainted with the tool:\nwhen a button is pressed some text appears in a richtexbox on the startup form when another button is pressed animate one or more colored balls within a rectangle\nMy Solution Code in C#\nCode in VB.net\nCode in zip(mirror)\nForm code In C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public MyFristGUI() { InitializeComponent(); t.Interval = 4; flag = new Bitmap(480, 160); g = Graphics.FromImage(flag); t.Tick += T_Tick; } Bitmap flag; Graphics g; int x = 20; int y = 20; Timer t = new Timer(); private void button1_Click(object sender, EventArgs e) { this.richTextBox1.Text = \u0026#34;button pressed\u0026#34;; } private void T_Tick(object sender, EventArgs e) { var rand2 = new Random(); g = Graphics.FromImage(flag); g.Clear(Color.White); g.DrawCircle(new Pen(Brushes.Red, 2), x, y, 20); g.FillCircle(Brushes.Red, x, y, 20); x = x+rand2.Next(-10, 10); y = y+ rand2.Next(-10,10); if (x \u0026gt; 460) x = x - 10; if (x \u0026lt; 20) x = x + 10; if (y \u0026gt; 140) y = y - 10; if (y \u0026lt; 20) y = y + 10; pictureBox2.Image = flag; } private void MyFristGUI_Load(object sender, EventArgs e) { } private void button2_MouseClick(object sender, MouseEventArgs e) { var rand = new Random(); x = rand.Next(20, 460); y = rand.Next(20, 140); t.Start(); this.button2.Visible = false; this.button3.Text = \u0026#34;STOP\u0026#34;; this.button3.Visible = true; } private void button3_MouseClick(object sender, MouseEventArgs e) { t.Stop(); g.Clear(BackColor); this.button3.Visible = false; this.button2.Visible = true; pictureBox2.Image = flag; } } ","date":"2019-04-26T20:03:36+02:00","image":"https://www.matteobianchi.eu/p/1_a/images/2_hu44e40e24614873f9ee517a8748991195_20240_120x120_fill_box_smart1_3.png","permalink":"https://www.matteobianchi.eu/p/1_a/","title":"1_A"},{"content":"This section: I have included in this section the various research and materials about the course of statistics held at Sapienza for Cybersecurity Master.\nWeekly works Here you can find the work of the various week:\nWeek1\nWeek2\nWeek3\nWeek4\nWeek5\nWeek6\nWeek7\nWeek8\nWeek9\nFinal mini thesis My final mini-thesis on the CTL can be found at:CTL-studies.\nLatex source code of this will be disclosed after the end of my exam.\nOther info For any other info you can contact me at yuky2020@gmail.com\nThe git for the VS projects https://github.com/yuky2020/Statistics-Pratical-LABS\n","date":"2018-04-26T20:03:36+02:00","permalink":"https://www.matteobianchi.eu/p/map-of-this-section/","title":"Map of this section"}]